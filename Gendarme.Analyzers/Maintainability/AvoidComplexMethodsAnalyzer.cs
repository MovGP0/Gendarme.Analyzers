namespace Gendarme.Analyzers.Maintainability;

/// <summary>
/// This rule computes the cyclomatic complexity (CC) for every method
/// and reports any method with a CC over 25 (this limit is configurable).
/// Large CC value often indicate complex code that is hard to understand and maintain.
/// It’s likely that breaking the method into several methods will help readability.
/// This rule won’t report any defects on code generated by the compiler or by tools.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class AvoidComplexMethodsAnalyzer : DiagnosticAnalyzer
{
    private static readonly LocalizableString Title = new LocalizableResourceString(nameof(Strings.AvoidComplexMethodsTitle), Strings.ResourceManager, typeof(Strings));
    private static readonly LocalizableString MessageFormat = new LocalizableResourceString(nameof(Strings.AvoidComplexMethodsMessage), Strings.ResourceManager, typeof(Strings));
    private static readonly LocalizableString Description = new LocalizableResourceString(nameof(Strings.AvoidComplexMethodsDescription), Strings.ResourceManager, typeof(Strings));

    private static readonly DiagnosticDescriptor Rule = new(
        DiagnosticId.AvoidComplexMethods,
        Title,
        MessageFormat,
        Category.Maintainability,
        DiagnosticSeverity.Info,
        isEnabledByDefault: true,
        description: Description);

    /// <summary>
    /// Methods with cyclomatic complexity greater than this will be reported as error.
    /// </summary>
    private const int HighThreshold = 100;

    /// <summary>
    /// Methods with cyclomatic complexity greater than this will be reported as warning.
    /// </summary>
    private const int MediumThreshold = 50;

    /// <summary>
    /// Methods with cyclomatic complexity greater than this will be reported as information.
    /// </summary>
    private const int LowThreshold = 25;

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        // Standard Roslyn analyzer initialization
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        context.RegisterSyntaxNodeAction(AnalyzeMethodSyntax, SyntaxKind.MethodDeclaration, SyntaxKind.ConstructorDeclaration);
    }

    private static void AnalyzeMethodSyntax(SyntaxNodeAnalysisContext context)
    {
        if (context.Node is MethodDeclarationSyntax methodDeclaration)
        {
            var complexity = CalculateCyclomaticComplexity(methodDeclaration);
            if (complexity > LowThreshold)
            {
                var diagnostic = Diagnostic.Create(
                    descriptor: Rule,
                    location: methodDeclaration.Identifier.GetLocation(),
                    effectiveSeverity: GetSeverity(complexity),
                    additionalLocations: null,
                    properties: null,
                    messageArgs: [
                        methodDeclaration.Identifier.ValueText,
                        complexity
                    ]);

                context.ReportDiagnostic(diagnostic);
            }
        }
        else if (context.Node is ConstructorDeclarationSyntax constructorDeclaration)
        {
            var complexity = CalculateCyclomaticComplexity(constructorDeclaration);
            if (complexity > LowThreshold)
            {
                var diagnostic = Diagnostic.Create(
                    descriptor: Rule,
                    location: constructorDeclaration.Identifier.GetLocation(),
                    effectiveSeverity: GetSeverity(complexity),
                    additionalLocations: null,
                    properties: null,
                    messageArgs: [
                        constructorDeclaration.Identifier.ValueText,
                        complexity
                    ]);

                context.ReportDiagnostic(diagnostic);
            }
        }
    }

    private static DiagnosticSeverity GetSeverity(int complexity)
    {
        return complexity switch
        {
            > HighThreshold => DiagnosticSeverity.Error,
            > MediumThreshold => DiagnosticSeverity.Warning,
            _ => DiagnosticSeverity.Info
        };
    }

    private static int CalculateCyclomaticComplexity(SyntaxNode node)
    {
        int complexity = 1;

        var descendants = node.DescendantNodes().ToArray();

        complexity += descendants.OfType<IfStatementSyntax>().Count();
        complexity += descendants.OfType<WhileStatementSyntax>().Count();
        complexity += descendants.OfType<DoStatementSyntax>().Count();
        complexity += descendants.OfType<ForStatementSyntax>().Count();
        complexity += descendants.OfType<ForEachStatementSyntax>().Count();
        complexity += descendants.OfType<ForEachVariableStatementSyntax>().Count();
        complexity += descendants.OfType<CaseSwitchLabelSyntax>().Count();
        complexity += descendants.OfType<ConditionalExpressionSyntax>().Count();
        complexity += descendants.OfType<CatchClauseSyntax>().Count();
        complexity += descendants
            .OfType<BinaryExpressionSyntax>()
            .Count(exp => exp.IsKind(SyntaxKind.LogicalAndExpression) || exp.IsKind(SyntaxKind.LogicalOrExpression));

        return complexity;
    }
}