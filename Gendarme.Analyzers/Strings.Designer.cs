//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Gendarme.Analyzers {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Strings {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Strings() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Gendarme.Analyzers.Strings", typeof(Strings).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Abstract types should not expose public constructors as they can only be instantiated by derived types. A protected constructor is more appropriate for these cases..
        /// </summary>
        internal static string AbstractTypesShouldNotHavePublicConstructorsDescription {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHavePublicConstructorsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Abstract type &apos;{0}&apos; has a public constructor. Consider changing it to protected to clarify the type&apos;s intended usage..
        /// </summary>
        internal static string AbstractTypesShouldNotHavePublicConstructorsMessage {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHavePublicConstructorsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Abstract types should not have public constructors.
        /// </summary>
        internal static string AbstractTypesShouldNotHavePublicConstructorsTitle {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHavePublicConstructorsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types that are not sealed and have a LinkDemand should also have an InheritanceDemand for the same permissions to prevent security issues arising from subclassing..
        /// </summary>
        internal static string AddMissingTypeInheritanceDemandDescription {
            get {
                return ResourceManager.GetString("AddMissingTypeInheritanceDemandDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; is not sealed and has a LinkDemand but lacks an InheritanceDemand.
        /// </summary>
        internal static string AddMissingTypeInheritanceDemandMessage {
            get {
                return ResourceManager.GetString("AddMissingTypeInheritanceDemandMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add missing InheritanceDemand for unsealed types with LinkDemand.
        /// </summary>
        internal static string AddMissingTypeInheritanceDemandTitle {
            get {
                return ResourceManager.GetString("AddMissingTypeInheritanceDemandTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Marking a public array field as readonly only prevents the field from being assigned a different array instance. The array elements can still be modified. This can lead to unexpected behavior and security issues..
        /// </summary>
        internal static string ArrayFieldsShouldNotBeReadOnlyDescription {
            get {
                return ResourceManager.GetString("ArrayFieldsShouldNotBeReadOnlyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Public readonly array field &apos;{0}&apos; can be modified externally.
        /// </summary>
        internal static string ArrayFieldsShouldNotBeReadOnlyMessage {
            get {
                return ResourceManager.GetString("ArrayFieldsShouldNotBeReadOnlyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Array fields should not be public and readonly.
        /// </summary>
        internal static string ArrayFieldsShouldNotBeReadOnlyTitle {
            get {
                return ResourceManager.GetString("ArrayFieldsShouldNotBeReadOnlyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All assembly version attributes should be consistent..
        /// </summary>
        internal static string AssemblyVersionMismatch_Description {
            get {
                return ResourceManager.GetString("AssemblyVersionMismatch_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to https://www.mono-project.com/docs/tools+libraries/tools/gendarme/rules/bad-practice/#avoidassemblyversionmismatchrule.
        /// </summary>
        internal static string AssemblyVersionMismatch_HelpLink {
            get {
                return ResourceManager.GetString("AssemblyVersionMismatch_HelpLink", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assembly version &apos;{0}&apos; does not match other version attributes.
        /// </summary>
        internal static string AssemblyVersionMismatch_Message {
            get {
                return ResourceManager.GetString("AssemblyVersionMismatch_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assembly version mismatch.
        /// </summary>
        internal static string AssemblyVersionMismatch_Title {
            get {
                return ResourceManager.GetString("AssemblyVersionMismatch_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is generally not useful to set state in an attribute without providing a way to retrieve it. Provide appropriately cased properties for constructor parameters..
        /// </summary>
        internal static string AttributeArgumentsShouldHaveAccessorsDescription {
            get {
                return ResourceManager.GetString("AttributeArgumentsShouldHaveAccessorsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Attribute &apos;{0}&apos; constructor parameter &apos;{1}&apos; is not exposed by a property. Consider adding a property named &apos;{1}&apos; (Pascal-cased)..
        /// </summary>
        internal static string AttributeArgumentsShouldHaveAccessorsMessage {
            get {
                return ResourceManager.GetString("AttributeArgumentsShouldHaveAccessorsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Attribute arguments should be exposed via properties.
        /// </summary>
        internal static string AttributeArgumentsShouldHaveAccessorsTitle {
            get {
                return ResourceManager.GetString("AttributeArgumentsShouldHaveAccessorsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks attributes with certain types (Version, Guid, Uri) and validates the string value..
        /// </summary>
        internal static string AttributeStringLiteralsShouldParseCorrectly_Description {
            get {
                return ResourceManager.GetString("AttributeStringLiteralsShouldParseCorrectly_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to String literal in attribute does not parse correctly: &apos;{0}&apos;.
        /// </summary>
        internal static string AttributeStringLiteralsShouldParseCorrectly_Message {
            get {
                return ResourceManager.GetString("AttributeStringLiteralsShouldParseCorrectly_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Attribute string literals should parse correctly.
        /// </summary>
        internal static string AttributeStringLiteralsShouldParseCorrectly_Title {
            get {
                return ResourceManager.GetString("AttributeStringLiteralsShouldParseCorrectly_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fields that are never assigned a value and remain null can lead to NullReferenceExceptions and should be initialized or removed if unnecessary.
        /// </summary>
        internal static string AvoidAlwaysNullFieldDescription {
            get {
                return ResourceManager.GetString("AvoidAlwaysNullFieldDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field &apos;{0}&apos; is always null and is never assigned a value.
        /// </summary>
        internal static string AvoidAlwaysNullFieldMessage {
            get {
                return ResourceManager.GetString("AvoidAlwaysNullFieldMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid fields that are always null.
        /// </summary>
        internal static string AvoidAlwaysNullFieldTitle {
            get {
                return ResourceManager.GetString("AvoidAlwaysNullFieldTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that exceptions derived from ArgumentException provide meaningful parameter names and messages.
        /// </summary>
        internal static string AvoidArgumentExceptionDefaultConstructorDescription {
            get {
                return ResourceManager.GetString("AvoidArgumentExceptionDefaultConstructorDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of default constructor for {0} is discouraged; provide parameter name and message.
        /// </summary>
        internal static string AvoidArgumentExceptionDefaultConstructorMessage {
            get {
                return ResourceManager.GetString("AvoidArgumentExceptionDefaultConstructorMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid using default constructor for {0}.
        /// </summary>
        internal static string AvoidArgumentExceptionDefaultConstructorTitle {
            get {
                return ResourceManager.GetString("AvoidArgumentExceptionDefaultConstructorTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid using methods that are known to be problematic due to potential issues such as performance problems or incorrect behavior..
        /// </summary>
        internal static string AvoidCallingProblematicMethods_Description {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethods_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; is considered problematic..
        /// </summary>
        internal static string AvoidCallingProblematicMethods_Message {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethods_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid problematic methods.
        /// </summary>
        internal static string AvoidCallingProblematicMethods_Title {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethods_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Duplicated code within a class makes maintenance harder. Extract common code into methods to improve reusability and readability..
        /// </summary>
        internal static string AvoidCodeDuplicatedInSameClassDescription {
            get {
                return ResourceManager.GetString("AvoidCodeDuplicatedInSameClassDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Code is duplicated within the same class.
        /// </summary>
        internal static string AvoidCodeDuplicatedInSameClassMessage {
            get {
                return ResourceManager.GetString("AvoidCodeDuplicatedInSameClassMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid code duplication in the same class.
        /// </summary>
        internal static string AvoidCodeDuplicatedInSameClassTitle {
            get {
                return ResourceManager.GetString("AvoidCodeDuplicatedInSameClassTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Duplicated code across sibling classes can lead to maintenance issues. Consider moving common code to a base class or utility class..
        /// </summary>
        internal static string AvoidCodeDuplicatedInSiblingClassesDescription {
            get {
                return ResourceManager.GetString("AvoidCodeDuplicatedInSiblingClassesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Code is duplicated across sibling classes.
        /// </summary>
        internal static string AvoidCodeDuplicatedInSiblingClassesMessage {
            get {
                return ResourceManager.GetString("AvoidCodeDuplicatedInSiblingClassesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid code duplication in sibling classes.
        /// </summary>
        internal static string AvoidCodeDuplicatedInSiblingClassesTitle {
            get {
                return ResourceManager.GetString("AvoidCodeDuplicatedInSiblingClassesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods with high cyclomatic complexity are difficult to understand and maintain. Consider refactoring to reduce complexity..
        /// </summary>
        internal static string AvoidComplexMethodsDescription {
            get {
                return ResourceManager.GetString("AvoidComplexMethodsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; has a cyclomatic complexity of {1}, which is higher than the allowed threshold.
        /// </summary>
        internal static string AvoidComplexMethodsMessage {
            get {
                return ResourceManager.GetString("AvoidComplexMethodsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid complex methods.
        /// </summary>
        internal static string AvoidComplexMethodsTitle {
            get {
                return ResourceManager.GetString("AvoidComplexMethodsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for types that contain only static members and fires if the type contains a visible instance constructor..
        /// </summary>
        internal static string AvoidConstructorsInStaticTypes_Description {
            get {
                return ResourceManager.GetString("AvoidConstructorsInStaticTypes_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static type &apos;{0}&apos; contains a constructor.
        /// </summary>
        internal static string AvoidConstructorsInStaticTypes_Message {
            get {
                return ResourceManager.GetString("AvoidConstructorsInStaticTypes_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid constructors in static types.
        /// </summary>
        internal static string AvoidConstructorsInStaticTypes_Title {
            get {
                return ResourceManager.GetString("AvoidConstructorsInStaticTypes_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Deep inheritance hierarchies can make code difficult to understand and maintain. Consider refactoring to reduce inheritance depth..
        /// </summary>
        internal static string AvoidDeepInheritanceTreeDescription {
            get {
                return ResourceManager.GetString("AvoidDeepInheritanceTreeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; has an inheritance depth of {1}, which exceeds the maximum allowed depth.
        /// </summary>
        internal static string AvoidDeepInheritanceTreeMessage {
            get {
                return ResourceManager.GetString("AvoidDeepInheritanceTreeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid deep inheritance trees.
        /// </summary>
        internal static string AvoidDeepInheritanceTreeTitle {
            get {
                return ResourceManager.GetString("AvoidDeepInheritanceTreeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Deeply nested namespaces can make code harder to read and maintain. Consider refactoring to reduce the namespace depth..
        /// </summary>
        internal static string AvoidDeepNamespaceHierarchyDescription {
            get {
                return ResourceManager.GetString("AvoidDeepNamespaceHierarchyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Namespace &apos;{0}&apos; has a depth of {1}, which exceeds the maximum allowed depth.
        /// </summary>
        internal static string AvoidDeepNamespaceHierarchyMessage {
            get {
                return ResourceManager.GetString("AvoidDeepNamespaceHierarchyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid deep namespace hierarchy.
        /// </summary>
        internal static string AvoidDeepNamespaceHierarchyTitle {
            get {
                return ResourceManager.GetString("AvoidDeepNamespaceHierarchyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty interfaces are generally not useful except as markers; use attributes instead to categorize or mark types..
        /// </summary>
        internal static string AvoidEmptyInterfaceDescription {
            get {
                return ResourceManager.GetString("AvoidEmptyInterfaceDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interface &apos;{0}&apos; is empty. Consider removing it or using an attribute for marker semantics..
        /// </summary>
        internal static string AvoidEmptyInterfaceMessage {
            get {
                return ResourceManager.GetString("AvoidEmptyInterfaceMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid empty interfaces.
        /// </summary>
        internal static string AvoidEmptyInterfaceTitle {
            get {
                return ResourceManager.GetString("AvoidEmptyInterfaceTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Extension methods should not be used to extend System.Object. Such extension methods cannot be consumed by some languages, like VB.NET, which use late-binding on System.Object instances..
        /// </summary>
        internal static string AvoidExtensionMethodOnSystemObject_Description {
            get {
                return ResourceManager.GetString("AvoidExtensionMethodOnSystemObject_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Extension method &apos;{0}&apos; should not be defined on System.Object.
        /// </summary>
        internal static string AvoidExtensionMethodOnSystemObject_Message {
            get {
                return ResourceManager.GetString("AvoidExtensionMethodOnSystemObject_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid extension method on System.Object.
        /// </summary>
        internal static string AvoidExtensionMethodOnSystemObject_Title {
            get {
                return ResourceManager.GetString("AvoidExtensionMethodOnSystemObject_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In general floating point numbers cannot be usefully compared using the equality and inequality operators..
        /// </summary>
        internal static string AvoidFloatingPointEquality_Description {
            get {
                return ResourceManager.GetString("AvoidFloatingPointEquality_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Floating point comparison with equality operator may cause unexpected results.
        /// </summary>
        internal static string AvoidFloatingPointEquality_Message {
            get {
                return ResourceManager.GetString("AvoidFloatingPointEquality_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid floating point equality comparison.
        /// </summary>
        internal static string AvoidFloatingPointEquality_Title {
            get {
                return ResourceManager.GetString("AvoidFloatingPointEquality_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types with low cohesion are often doing too many unrelated things, making them hard to understand and maintain. Consider refactoring..
        /// </summary>
        internal static string AvoidLackOfCohesionOfMethodsDescription {
            get {
                return ResourceManager.GetString("AvoidLackOfCohesionOfMethodsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; has a lack of cohesion value of {1}, indicating low cohesion.
        /// </summary>
        internal static string AvoidLackOfCohesionOfMethodsMessage {
            get {
                return ResourceManager.GetString("AvoidLackOfCohesionOfMethodsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid types with low cohesion.
        /// </summary>
        internal static string AvoidLackOfCohesionOfMethodsTitle {
            get {
                return ResourceManager.GetString("AvoidLackOfCohesionOfMethodsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Classes that are too large are harder to maintain. Consider splitting this class into smaller, more focused classes..
        /// </summary>
        internal static string AvoidLargeClassesDescription {
            get {
                return ResourceManager.GetString("AvoidLargeClassesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Class &apos;{0}&apos; is too large.
        /// </summary>
        internal static string AvoidLargeClassesMessage {
            get {
                return ResourceManager.GetString("AvoidLargeClassesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid large classes.
        /// </summary>
        internal static string AvoidLargeClassesTitle {
            get {
                return ResourceManager.GetString("AvoidLargeClassesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods with too many local variables can be hard to understand and maintain. Consider refactoring to reduce the number of local variables..
        /// </summary>
        internal static string AvoidLargeNumberOfLocalVariablesDescription {
            get {
                return ResourceManager.GetString("AvoidLargeNumberOfLocalVariablesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; contains {1} local variables, exceeding the maximum allowed ({2}).
        /// </summary>
        internal static string AvoidLargeNumberOfLocalVariablesMessage {
            get {
                return ResourceManager.GetString("AvoidLargeNumberOfLocalVariablesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid methods with a large number of local variables.
        /// </summary>
        internal static string AvoidLargeNumberOfLocalVariablesTitle {
            get {
                return ResourceManager.GetString("AvoidLargeNumberOfLocalVariablesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Large value types can negatively impact performance due to copying overhead. Consider converting to a reference type or reducing its size..
        /// </summary>
        internal static string AvoidLargeStructureDescription {
            get {
                return ResourceManager.GetString("AvoidLargeStructureDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Structure &apos;{0}&apos; is larger than {1} bytes.
        /// </summary>
        internal static string AvoidLargeStructureMessage {
            get {
                return ResourceManager.GetString("AvoidLargeStructureMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid large structures (value types).
        /// </summary>
        internal static string AvoidLargeStructureTitle {
            get {
                return ResourceManager.GetString("AvoidLargeStructureTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods that are too long are harder to understand and maintain. Consider refactoring this method into smaller methods..
        /// </summary>
        internal static string AvoidLongMethodsDescription {
            get {
                return ResourceManager.GetString("AvoidLongMethodsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; is too long.
        /// </summary>
        internal static string AvoidLongMethodsMessage {
            get {
                return ResourceManager.GetString("AvoidLongMethodsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid long methods.
        /// </summary>
        internal static string AvoidLongMethodsTitle {
            get {
                return ResourceManager.GetString("AvoidLongMethodsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods with long parameter lists can be hard to use and maintain. Consider refactoring to reduce the number of parameters..
        /// </summary>
        internal static string AvoidLongParameterListsDescription {
            get {
                return ResourceManager.GetString("AvoidLongParameterListsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; has too many parameters.
        /// </summary>
        internal static string AvoidLongParameterListsMessage {
            get {
                return ResourceManager.GetString("AvoidLongParameterListsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid long parameter lists.
        /// </summary>
        internal static string AvoidLongParameterListsTitle {
            get {
                return ResourceManager.GetString("AvoidLongParameterListsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Long message chains indicate tight coupling to object navigation structures. Consider refactoring to reduce dependencies..
        /// </summary>
        internal static string AvoidMessageChainsDescription {
            get {
                return ResourceManager.GetString("AvoidMessageChainsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Message chain detected in method &apos;{0}&apos;.
        /// </summary>
        internal static string AvoidMessageChainsMessage {
            get {
                return ResourceManager.GetString("AvoidMessageChainsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid message chains.
        /// </summary>
        internal static string AvoidMessageChainsTitle {
            get {
                return ResourceManager.GetString("AvoidMessageChainsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unused generic type parameters can be removed.
        /// </summary>
        internal static string AvoidMethodWithUnusedGenericType_Description {
            get {
                return ResourceManager.GetString("AvoidMethodWithUnusedGenericType_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Generic type parameter &apos;{0}&apos; is not used in method parameters.
        /// </summary>
        internal static string AvoidMethodWithUnusedGenericType_Message {
            get {
                return ResourceManager.GetString("AvoidMethodWithUnusedGenericType_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid Method with unused generic-type parameter.
        /// </summary>
        internal static string AvoidMethodWithUnusedGenericType_Title {
            get {
                return ResourceManager.GetString("AvoidMethodWithUnusedGenericType_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unused generic types should be utilized in method parameters or removed to improve code clarity..
        /// </summary>
        internal static string AvoidMethodWithUnusedGenericTypeAnalyzer_Description {
            get {
                return ResourceManager.GetString("AvoidMethodWithUnusedGenericTypeAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Generic type parameter &apos;{0}&apos; is not used in method parameters.
        /// </summary>
        internal static string AvoidMethodWithUnusedGenericTypeAnalyzer_Message {
            get {
                return ResourceManager.GetString("AvoidMethodWithUnusedGenericTypeAnalyzer_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid Method with Unused Generic Type Parameter.
        /// </summary>
        internal static string AvoidMethodWithUnusedGenericTypeAnalyzer_Title {
            get {
                return ResourceManager.GetString("AvoidMethodWithUnusedGenericTypeAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Indexers with multiple parameters can be confusing. IDE auto-complete doesn’t always handle them well. A method is often clearer for multi-parameter access..
        /// </summary>
        internal static string AvoidMultidimensionalIndexerDescription {
            get {
                return ResourceManager.GetString("AvoidMultidimensionalIndexerDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; has an indexer with multiple parameters. Consider using methods instead to avoid confusion and improve usability..
        /// </summary>
        internal static string AvoidMultidimensionalIndexerMessage {
            get {
                return ResourceManager.GetString("AvoidMultidimensionalIndexerMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid multidimensional indexers.
        /// </summary>
        internal static string AvoidMultidimensionalIndexerTitle {
            get {
                return ResourceManager.GetString("AvoidMultidimensionalIndexerTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers should only contain alphanumeric characters to improve readability and maintain coding standards..
        /// </summary>
        internal static string AvoidNonAlphanumericIdentifierDescription {
            get {
                return ResourceManager.GetString("AvoidNonAlphanumericIdentifierDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier &apos;{0}&apos; contains non-alphanumeric characters.
        /// </summary>
        internal static string AvoidNonAlphanumericIdentifierMessage {
            get {
                return ResourceManager.GetString("AvoidNonAlphanumericIdentifierMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid non-alphanumeric characters in identifiers.
        /// </summary>
        internal static string AvoidNonAlphanumericIdentifierTitle {
            get {
                return ResourceManager.GetString("AvoidNonAlphanumericIdentifierTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Properties with only a set accessor can be confusing to consumers. Generally, either provide both get and set accessors, or use a method to set the value..
        /// </summary>
        internal static string AvoidPropertiesWithoutGetAccessorDescription {
            get {
                return ResourceManager.GetString("AvoidPropertiesWithoutGetAccessorDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Property &apos;{0}&apos; is externally visible but lacks a get accessor. Add a getter or convert the property to a method..
        /// </summary>
        internal static string AvoidPropertiesWithoutGetAccessorMessage {
            get {
                return ResourceManager.GetString("AvoidPropertiesWithoutGetAccessorMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid properties without a get accessor.
        /// </summary>
        internal static string AvoidPropertiesWithoutGetAccessorTitle {
            get {
                return ResourceManager.GetString("AvoidPropertiesWithoutGetAccessorTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Removing the type name from the method name makes the API less verbose and easier to use..
        /// </summary>
        internal static string AvoidRedundancyInMethodNameDescription {
            get {
                return ResourceManager.GetString("AvoidRedundancyInMethodNameDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; embeds the type name of its first parameter &apos;{1}&apos;.
        /// </summary>
        internal static string AvoidRedundancyInMethodNameMessage {
            get {
                return ResourceManager.GetString("AvoidRedundancyInMethodNameMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid redundancy in method names.
        /// </summary>
        internal static string AvoidRedundancyInMethodNameTitle {
            get {
                return ResourceManager.GetString("AvoidRedundancyInMethodNameTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Removing redundant namespace prefixes from type names makes them less verbose and easier to use..
        /// </summary>
        internal static string AvoidRedundancyInTypeNameDescription {
            get {
                return ResourceManager.GetString("AvoidRedundancyInTypeNameDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; is prefixed with its namespace name &apos;{1}&apos;.
        /// </summary>
        internal static string AvoidRedundancyInTypeNameMessage {
            get {
                return ResourceManager.GetString("AvoidRedundancyInTypeNameMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid redundancy in type names.
        /// </summary>
        internal static string AvoidRedundancyInTypeNameTitle {
            get {
                return ResourceManager.GetString("AvoidRedundancyInTypeNameTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using ref/out parameters complicates method signatures and can be misused. Where possible, return values or use the bool Try*(out T) pattern. Provide simpler alternatives for most use cases..
        /// </summary>
        internal static string AvoidRefAndOutParametersDescription {
            get {
                return ResourceManager.GetString("AvoidRefAndOutParametersDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; uses &apos;{1}&apos; parameter. These can create confusion in public APIs. Consider alternative designs or use the bool Try*(out) pattern only..
        /// </summary>
        internal static string AvoidRefAndOutParametersMessage {
            get {
                return ResourceManager.GetString("AvoidRefAndOutParametersMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid ref and out parameters.
        /// </summary>
        internal static string AvoidRefAndOutParametersTitle {
            get {
                return ResourceManager.GetString("AvoidRefAndOutParametersTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Casting the same value multiple times is inefficient. Consider caching the casted value in a variable..
        /// </summary>
        internal static string AvoidRepetitiveCastsDescription {
            get {
                return ResourceManager.GetString("AvoidRepetitiveCastsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Value &apos;{0}&apos; is cast to &apos;{1}&apos; multiple times.
        /// </summary>
        internal static string AvoidRepetitiveCastsMessage {
            get {
                return ResourceManager.GetString("AvoidRepetitiveCastsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid repetitive casts on the same value.
        /// </summary>
        internal static string AvoidRepetitiveCastsTitle {
            get {
                return ResourceManager.GetString("AvoidRepetitiveCastsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Returning arrays from properties can expose internal state. Use methods to return copies or return a read-only collection instead..
        /// </summary>
        internal static string AvoidReturningArraysOnPropertiesDescription {
            get {
                return ResourceManager.GetString("AvoidReturningArraysOnPropertiesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Property &apos;{0}&apos; returns an array.
        /// </summary>
        internal static string AvoidReturningArraysOnPropertiesMessage {
            get {
                return ResourceManager.GetString("AvoidReturningArraysOnPropertiesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid returning arrays from properties.
        /// </summary>
        internal static string AvoidReturningArraysOnPropertiesTitle {
            get {
                return ResourceManager.GetString("AvoidReturningArraysOnPropertiesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Namespaces with few types can create unnecessary fragmentation. Consider combining small namespaces or organizing related types together..
        /// </summary>
        internal static string AvoidSmallNamespaceDescription {
            get {
                return ResourceManager.GetString("AvoidSmallNamespaceDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Namespace &apos;{0}&apos; contains only {1} externally visible type(s). At least {2} are recommended for clarity and organization..
        /// </summary>
        internal static string AvoidSmallNamespaceMessage {
            get {
                return ResourceManager.GetString("AvoidSmallNamespaceMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid small namespaces.
        /// </summary>
        internal static string AvoidSmallNamespaceTitle {
            get {
                return ResourceManager.GetString("AvoidSmallNamespaceTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unused abstractions or parameters may indicate speculative generality. Remove unnecessary code to improve clarity..
        /// </summary>
        internal static string AvoidSpeculativeGeneralityDescription {
            get {
                return ResourceManager.GetString("AvoidSpeculativeGeneralityDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Speculative generality detected in &apos;{0}&apos;.
        /// </summary>
        internal static string AvoidSpeculativeGeneralityMessage {
            get {
                return ResourceManager.GetString("AvoidSpeculativeGeneralityMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid speculative generality.
        /// </summary>
        internal static string AvoidSpeculativeGeneralityTitle {
            get {
                return ResourceManager.GetString("AvoidSpeculativeGeneralityTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Switch statements can lead to duplicated code. Consider using polymorphism to achieve the same behavior..
        /// </summary>
        internal static string AvoidSwitchStatementsDescription {
            get {
                return ResourceManager.GetString("AvoidSwitchStatementsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Switch statement detected in method &apos;{0}&apos;.
        /// </summary>
        internal static string AvoidSwitchStatementsMessage {
            get {
                return ResourceManager.GetString("AvoidSwitchStatementsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid switch statements.
        /// </summary>
        internal static string AvoidSwitchStatementsTitle {
            get {
                return ResourceManager.GetString("AvoidSwitchStatementsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Throwing basic exceptions like System.Exception, System.ApplicationException, or System.SystemException does not provide enough information about the error to be helpful to the consumer of the library.
        /// </summary>
        internal static string AvoidThrowingBasicExceptionsDescription {
            get {
                return ResourceManager.GetString("AvoidThrowingBasicExceptionsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid throwing basic exception type &apos;{0}&apos;; throw a more specific exception instead.
        /// </summary>
        internal static string AvoidThrowingBasicExceptionsMessage {
            get {
                return ResourceManager.GetString("AvoidThrowingBasicExceptionsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid throwing basic exceptions.
        /// </summary>
        internal static string AvoidThrowingBasicExceptionsTitle {
            get {
                return ResourceManager.GetString("AvoidThrowingBasicExceptionsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using Type.GetType with constant strings is less efficient and can fail at runtime. Use the &apos;typeof&apos; operator instead..
        /// </summary>
        internal static string AvoidTypeGetTypeForConstantStringsDescription {
            get {
                return ResourceManager.GetString("AvoidTypeGetTypeForConstantStringsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;typeof({0})&apos; instead of &apos;Type.GetType(&quot;{1}&quot;)&apos;.
        /// </summary>
        internal static string AvoidTypeGetTypeForConstantStringsMessage {
            get {
                return ResourceManager.GetString("AvoidTypeGetTypeForConstantStringsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid using Type.GetType with constant strings.
        /// </summary>
        internal static string AvoidTypeGetTypeForConstantStringsTitle {
            get {
                return ResourceManager.GetString("AvoidTypeGetTypeForConstantStringsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If a type and an interface share the same base name, the type should implement the interface to meet expectations..
        /// </summary>
        internal static string AvoidTypeInterfaceInconsistencyDescription {
            get {
                return ResourceManager.GetString("AvoidTypeInterfaceInconsistencyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; does not implement the interface &apos;{1}&apos; with the same base name.
        /// </summary>
        internal static string AvoidTypeInterfaceInconsistencyMessage {
            get {
                return ResourceManager.GetString("AvoidTypeInterfaceInconsistencyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid type/interface inconsistency.
        /// </summary>
        internal static string AvoidTypeInterfaceInconsistencyTitle {
            get {
                return ResourceManager.GetString("AvoidTypeInterfaceInconsistencyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Private methods that are never called can be removed to reduce code clutter and potential confusion..
        /// </summary>
        internal static string AvoidUncalledPrivateCodeDescription {
            get {
                return ResourceManager.GetString("AvoidUncalledPrivateCodeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Private method &apos;{0}&apos; is never called.
        /// </summary>
        internal static string AvoidUncalledPrivateCodeMessage {
            get {
                return ResourceManager.GetString("AvoidUncalledPrivateCodeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid uncalled private code.
        /// </summary>
        internal static string AvoidUncalledPrivateCodeTitle {
            get {
                return ResourceManager.GetString("AvoidUncalledPrivateCodeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Internal classes that are never instantiated may be unused code and can be removed or made abstract if intended for inheritance..
        /// </summary>
        internal static string AvoidUninstantiatedInternalClassesDescription {
            get {
                return ResourceManager.GetString("AvoidUninstantiatedInternalClassesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Internal class &apos;{0}&apos; is never instantiated.
        /// </summary>
        internal static string AvoidUninstantiatedInternalClassesMessage {
            get {
                return ResourceManager.GetString("AvoidUninstantiatedInternalClassesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid uninstantiated internal classes.
        /// </summary>
        internal static string AvoidUninstantiatedInternalClassesTitle {
            get {
                return ResourceManager.GetString("AvoidUninstantiatedInternalClassesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using unnecessarily specialized parameter types reduces method reusability. Consider using more general types or interfaces..
        /// </summary>
        internal static string AvoidUnnecessarySpecializationDescription {
            get {
                return ResourceManager.GetString("AvoidUnnecessarySpecializationDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; can be of a more general type &apos;{1}&apos;.
        /// </summary>
        internal static string AvoidUnnecessarySpecializationMessage {
            get {
                return ResourceManager.GetString("AvoidUnnecessarySpecializationMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid unnecessary specialization in method parameters.
        /// </summary>
        internal static string AvoidUnnecessarySpecializationTitle {
            get {
                return ResourceManager.GetString("AvoidUnnecessarySpecializationTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods like &apos;ToString&apos; on string instances return the original string and are redundant. They can be safely removed..
        /// </summary>
        internal static string AvoidUnneededCallsOnStringDescription {
            get {
                return ResourceManager.GetString("AvoidUnneededCallsOnStringDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; called on string instance &apos;{1}&apos; is unnecessary.
        /// </summary>
        internal static string AvoidUnneededCallsOnStringMessage {
            get {
                return ResourceManager.GetString("AvoidUnneededCallsOnStringMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid unnecessary method calls on string instances.
        /// </summary>
        internal static string AvoidUnneededCallsOnStringTitle {
            get {
                return ResourceManager.GetString("AvoidUnneededCallsOnStringTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fields are automatically initialized to their default values. Explicitly assigning default values is redundant and can be removed..
        /// </summary>
        internal static string AvoidUnneededFieldInitializationDescription {
            get {
                return ResourceManager.GetString("AvoidUnneededFieldInitializationDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field &apos;{0}&apos; is initialized to its default value.
        /// </summary>
        internal static string AvoidUnneededFieldInitializationMessage {
            get {
                return ResourceManager.GetString("AvoidUnneededFieldInitializationMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid unnecessary field initialization.
        /// </summary>
        internal static string AvoidUnneededFieldInitializationTitle {
            get {
                return ResourceManager.GetString("AvoidUnneededFieldInitializationTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unboxing a value type multiple times is inefficient. Consider caching the unboxed value in a variable..
        /// </summary>
        internal static string AvoidUnneededUnboxingDescription {
            get {
                return ResourceManager.GetString("AvoidUnneededUnboxingDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Value type &apos;{0}&apos; is unboxed multiple times.
        /// </summary>
        internal static string AvoidUnneededUnboxingMessage {
            get {
                return ResourceManager.GetString("AvoidUnneededUnboxingMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid unnecessary unboxing.
        /// </summary>
        internal static string AvoidUnneededUnboxingTitle {
            get {
                return ResourceManager.GetString("AvoidUnneededUnboxingTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Concrete attribute classes should be sealed to improve performance. Alternatively, make the attribute class abstract..
        /// </summary>
        internal static string AvoidUnsealedConcreteAttributesDescription {
            get {
                return ResourceManager.GetString("AvoidUnsealedConcreteAttributesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Attribute class &apos;{0}&apos; is concrete and unsealed.
        /// </summary>
        internal static string AvoidUnsealedConcreteAttributesMessage {
            get {
                return ResourceManager.GetString("AvoidUnsealedConcreteAttributesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid unsealed concrete attribute classes.
        /// </summary>
        internal static string AvoidUnsealedConcreteAttributesTitle {
            get {
                return ResourceManager.GetString("AvoidUnsealedConcreteAttributesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sealing internal classes that are not inherited allows for compiler optimizations and clarifies the type hierarchy..
        /// </summary>
        internal static string AvoidUnsealedUninheritedInternalTypeDescription {
            get {
                return ResourceManager.GetString("AvoidUnsealedUninheritedInternalTypeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Internal class &apos;{0}&apos; is unsealed and not inherited.
        /// </summary>
        internal static string AvoidUnsealedUninheritedInternalTypeMessage {
            get {
                return ResourceManager.GetString("AvoidUnsealedUninheritedInternalTypeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid unsealed internal classes that are not inherited.
        /// </summary>
        internal static string AvoidUnsealedUninheritedInternalTypeTitle {
            get {
                return ResourceManager.GetString("AvoidUnsealedUninheritedInternalTypeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All parameters in a method should be used to avoid confusion and potential errors. Remove unused parameters or use them appropriately..
        /// </summary>
        internal static string AvoidUnusedParametersDescription {
            get {
                return ResourceManager.GetString("AvoidUnusedParametersDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; of method &apos;{1}&apos; is not used.
        /// </summary>
        internal static string AvoidUnusedParametersMessage {
            get {
                return ResourceManager.GetString("AvoidUnusedParametersMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid unused parameters.
        /// </summary>
        internal static string AvoidUnusedParametersTitle {
            get {
                return ResourceManager.GetString("AvoidUnusedParametersTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unused private fields increase code clutter and can lead to confusion. Remove unused fields to improve code clarity..
        /// </summary>
        internal static string AvoidUnusedPrivateFieldsDescription {
            get {
                return ResourceManager.GetString("AvoidUnusedPrivateFieldsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Private field &apos;{0}&apos; is never used.
        /// </summary>
        internal static string AvoidUnusedPrivateFieldsMessage {
            get {
                return ResourceManager.GetString("AvoidUnusedPrivateFieldsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid unused private fields.
        /// </summary>
        internal static string AvoidUnusedPrivateFieldsTitle {
            get {
                return ResourceManager.GetString("AvoidUnusedPrivateFieldsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid constant fields which are visible outside the current assembly. Use &apos;static readonly&apos; instead..
        /// </summary>
        internal static string AvoidVisibleConstantField_Description {
            get {
                return ResourceManager.GetString("AvoidVisibleConstantField_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The constant field &apos;{0}&apos; is visible outside the assembly.
        /// </summary>
        internal static string AvoidVisibleConstantField_Message {
            get {
                return ResourceManager.GetString("AvoidVisibleConstantField_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid visible constant field.
        /// </summary>
        internal static string AvoidVisibleConstantField_Title {
            get {
                return ResourceManager.GetString("AvoidVisibleConstantField_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exposing fields directly ties callers to the field’s storage and prevents future internal changes. Use properties (getters and setters) to provide a stable API..
        /// </summary>
        internal static string AvoidVisibleFieldsDescription {
            get {
                return ResourceManager.GetString("AvoidVisibleFieldsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field &apos;{0}&apos; is externally visible. Prefer using a property instead to preserve binary compatibility if the implementation changes..
        /// </summary>
        internal static string AvoidVisibleFieldsMessage {
            get {
                return ResourceManager.GetString("AvoidVisibleFieldsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid externally visible fields.
        /// </summary>
        internal static string AvoidVisibleFieldsTitle {
            get {
                return ResourceManager.GetString("AvoidVisibleFieldsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Publicly nested types can cause confusion because they appear as members rather than namespaced types. Consider scoping them within a namespace or marking them private..
        /// </summary>
        internal static string AvoidVisibleNestedTypesDescription {
            get {
                return ResourceManager.GetString("AvoidVisibleNestedTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Nested type &apos;{0}&apos; is externally visible. Nesting can confuse usage and documentation; consider making it private or top-level..
        /// </summary>
        internal static string AvoidVisibleNestedTypesMessage {
            get {
                return ResourceManager.GetString("AvoidVisibleNestedTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid externally visible nested types.
        /// </summary>
        internal static string AvoidVisibleNestedTypesTitle {
            get {
                return ResourceManager.GetString("AvoidVisibleNestedTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for methods that may be infinitely recursive..
        /// </summary>
        internal static string BadRecursiveInvocation_Description {
            get {
                return ResourceManager.GetString("BadRecursiveInvocation_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; recursively calls itself.
        /// </summary>
        internal static string BadRecursiveInvocation_Message {
            get {
                return ResourceManager.GetString("BadRecursiveInvocation_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid bad recursive invocation.
        /// </summary>
        internal static string BadRecursiveInvocation_Title {
            get {
                return ResourceManager.GetString("BadRecursiveInvocation_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types implementing ISerializable should call their base type&apos;s serialization constructor and GetObjectData method to ensure proper serialization..
        /// </summary>
        internal static string CallBaseMethodsOnISerializableTypesDescription {
            get {
                return ResourceManager.GetString("CallBaseMethodsOnISerializableTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ISerializable type &apos;{0}&apos; does not call base {1} method.
        /// </summary>
        internal static string CallBaseMethodsOnISerializableTypesMessage {
            get {
                return ResourceManager.GetString("CallBaseMethodsOnISerializableTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Call base methods in ISerializable types.
        /// </summary>
        internal static string CallBaseMethodsOnISerializableTypesTitle {
            get {
                return ResourceManager.GetString("CallBaseMethodsOnISerializableTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for methods that call Equals with a null actual parameter..
        /// </summary>
        internal static string CallingEqualsWithNullArg_Description {
            get {
                return ResourceManager.GetString("CallingEqualsWithNullArg_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; calls Equals with a null argument.
        /// </summary>
        internal static string CallingEqualsWithNullArg_Message {
            get {
                return ResourceManager.GetString("CallingEqualsWithNullArg_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid calling Equals with null argument.
        /// </summary>
        internal static string CallingEqualsWithNullArg_Title {
            get {
                return ResourceManager.GetString("CallingEqualsWithNullArg_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exception objects should be thrown, returned, or passed to another method as an argument..
        /// </summary>
        internal static string CheckNewExceptionWithoutThrowing_Description {
            get {
                return ResourceManager.GetString("CheckNewExceptionWithoutThrowing_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The exception &apos;{0}&apos; is created but not thrown, not returned, and not passed to another method.
        /// </summary>
        internal static string CheckNewExceptionWithoutThrowing_Message {
            get {
                return ResourceManager.GetString("CheckNewExceptionWithoutThrowing_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exception object created but not thrown or used.
        /// </summary>
        internal static string CheckNewExceptionWithoutThrowing_Title {
            get {
                return ResourceManager.GetString("CheckNewExceptionWithoutThrowing_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Thread objects should be started, returned, or passed to another method as an argument..
        /// </summary>
        internal static string CheckNewThreadWithoutStart_Description {
            get {
                return ResourceManager.GetString("CheckNewThreadWithoutStart_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The thread &apos;{0}&apos; is created but not started, not returned, and not passed to another method.
        /// </summary>
        internal static string CheckNewThreadWithoutStart_Message {
            get {
                return ResourceManager.GetString("CheckNewThreadWithoutStart_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Thread object created but not started or used.
        /// </summary>
        internal static string CheckNewThreadWithoutStart_Title {
            get {
                return ResourceManager.GetString("CheckNewThreadWithoutStart_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks if all nullable parameters of visible methods are compared with null before they get used..
        /// </summary>
        internal static string CheckParametersNullityInVisibleMethods_Description {
            get {
                return ResourceManager.GetString("CheckParametersNullityInVisibleMethods_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; is not checked for null.
        /// </summary>
        internal static string CheckParametersNullityInVisibleMethods_Message {
            get {
                return ResourceManager.GetString("CheckParametersNullityInVisibleMethods_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Check nullable parameters for null before use.
        /// </summary>
        internal static string CheckParametersNullityInVisibleMethods_Title {
            get {
                return ResourceManager.GetString("CheckParametersNullityInVisibleMethods_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Clone methods should not return null. They should return a new object instance..
        /// </summary>
        internal static string CloneMethodShouldNotReturnNull_Description {
            get {
                return ResourceManager.GetString("CloneMethodShouldNotReturnNull_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Clone method returns null.
        /// </summary>
        internal static string CloneMethodShouldNotReturnNull_Message {
            get {
                return ResourceManager.GetString("CloneMethodShouldNotReturnNull_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Clone method should not return null.
        /// </summary>
        internal static string CloneMethodShouldNotReturnNull_Title {
            get {
                return ResourceManager.GetString("CloneMethodShouldNotReturnNull_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Comparing string length is more efficient than comparing to empty strings or String.Empty. Consider using &apos;string.IsNullOrEmpty&apos; when appropriate..
        /// </summary>
        internal static string CompareWithEmptyStringEfficientlyDescription {
            get {
                return ResourceManager.GetString("CompareWithEmptyStringEfficientlyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;string.Length == 0&apos; instead of comparing to &apos;{0}&apos;.
        /// </summary>
        internal static string CompareWithEmptyStringEfficientlyMessage {
            get {
                return ResourceManager.GetString("CompareWithEmptyStringEfficientlyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Compare strings with empty string efficiently.
        /// </summary>
        internal static string CompareWithEmptyStringEfficientlyTitle {
            get {
                return ResourceManager.GetString("CompareWithEmptyStringEfficientlyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implementing an interface clarifies semantics and increases reusability. If a type already implements common interface members, explicitly implement that interface for clarity..
        /// </summary>
        internal static string ConsiderAddingInterfaceDescription {
            get {
                return ResourceManager.GetString("ConsiderAddingInterfaceDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; implements members that appear to match an interface, but does not explicitly implement that interface..
        /// </summary>
        internal static string ConsiderAddingInterfaceMessage {
            get {
                return ResourceManager.GetString("ConsiderAddingInterfaceMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider adding an interface for common members.
        /// </summary>
        internal static string ConsiderAddingInterfaceTitle {
            get {
                return ResourceManager.GetString("ConsiderAddingInterfaceTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for pairs of fields which seem to provide the same functionality as a single nullable field..
        /// </summary>
        internal static string ConsiderConvertingFieldToNullableDescription {
            get {
                return ResourceManager.GetString("ConsiderConvertingFieldToNullableDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; has fields that could be combined into a nullable field..
        /// </summary>
        internal static string ConsiderConvertingFieldToNullableMessage {
            get {
                return ResourceManager.GetString("ConsiderConvertingFieldToNullableMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider converting field to nullable.
        /// </summary>
        internal static string ConsiderConvertingFieldToNullableTitle {
            get {
                return ResourceManager.GetString("ConsiderConvertingFieldToNullableTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Checks for methods whose definition looks similar to a property (e.g. name starts with &apos;Get&apos; or &apos;Is&apos;, has no parameters, etc.)..
        /// </summary>
        internal static string ConsiderConvertingMethodToPropertyDescription {
            get {
                return ResourceManager.GetString("ConsiderConvertingMethodToPropertyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; appears to be a candidate for a property..
        /// </summary>
        internal static string ConsiderConvertingMethodToPropertyMessage {
            get {
                return ResourceManager.GetString("ConsiderConvertingMethodToPropertyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider converting method to property.
        /// </summary>
        internal static string ConsiderConvertingMethodToPropertyTitle {
            get {
                return ResourceManager.GetString("ConsiderConvertingMethodToPropertyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Default event accessors are synchronized, which can impact performance. For non-visible events, consider custom accessors without synchronization if thread safety is managed elsewhere..
        /// </summary>
        internal static string ConsiderCustomAccessorsForNonVisibleEventsDescription {
            get {
                return ResourceManager.GetString("ConsiderCustomAccessorsForNonVisibleEventsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-visible event &apos;{0}&apos; uses default synchronized accessors.
        /// </summary>
        internal static string ConsiderCustomAccessorsForNonVisibleEventsMessage {
            get {
                return ResourceManager.GetString("ConsiderCustomAccessorsForNonVisibleEventsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider custom accessors for non-visible events.
        /// </summary>
        internal static string ConsiderCustomAccessorsForNonVisibleEventsTitle {
            get {
                return ResourceManager.GetString("ConsiderCustomAccessorsForNonVisibleEventsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for types that contain only static members and suggests that the type be made static..
        /// </summary>
        internal static string ConsiderUsingStaticTypeDescription {
            get {
                return ResourceManager.GetString("ConsiderUsingStaticTypeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; contains only static members and can be declared static..
        /// </summary>
        internal static string ConsiderUsingStaticTypeMessage {
            get {
                return ResourceManager.GetString("ConsiderUsingStaticTypeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider using static type.
        /// </summary>
        internal static string ConsiderUsingStaticTypeTitle {
            get {
                return ResourceManager.GetString("ConsiderUsingStaticTypeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Stopwatch provides more accurate timing and better expresses the intent of measuring elapsed time..
        /// </summary>
        internal static string ConsiderUsingStopwatchDescription {
            get {
                return ResourceManager.GetString("ConsiderUsingStopwatchDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider using System.Diagnostics.Stopwatch instead of DateTime.Now for measuring elapsed time.
        /// </summary>
        internal static string ConsiderUsingStopwatchMessage {
            get {
                return ResourceManager.GetString("ConsiderUsingStopwatchMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider using Stopwatch instead of DateTime for timing.
        /// </summary>
        internal static string ConsiderUsingStopwatchTitle {
            get {
                return ResourceManager.GetString("ConsiderUsingStopwatchTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructors of non-sealed types should not call virtual methods. This can lead to fragile code if the method is overridden in a derived class..
        /// </summary>
        internal static string ConstructorShouldNotCallVirtualMethods_Description {
            get {
                return ResourceManager.GetString("ConstructorShouldNotCallVirtualMethods_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The constructor calls the virtual method &apos;{0}&apos;.
        /// </summary>
        internal static string ConstructorShouldNotCallVirtualMethods_Message {
            get {
                return ResourceManager.GetString("ConstructorShouldNotCallVirtualMethods_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructor should not call virtual methods.
        /// </summary>
        internal static string ConstructorShouldNotCallVirtualMethods_Title {
            get {
                return ResourceManager.GetString("ConstructorShouldNotCallVirtualMethods_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Events should have a void return type and take two parameters: object sender and EventArgs e (or derived)..
        /// </summary>
        internal static string DeclareEventHandlersCorrectlyDescription {
            get {
                return ResourceManager.GetString("DeclareEventHandlersCorrectlyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Event &apos;{0}&apos; does not match .NET event handler guidelines..
        /// </summary>
        internal static string DeclareEventHandlersCorrectlyMessage {
            get {
                return ResourceManager.GetString("DeclareEventHandlersCorrectlyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declare event handlers correctly.
        /// </summary>
        internal static string DeclareEventHandlersCorrectlyTitle {
            get {
                return ResourceManager.GetString("DeclareEventHandlersCorrectlyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delegates passed to native code must handle exceptions to prevent unhandled exceptions from propagating into unmanaged code..
        /// </summary>
        internal static string DelegatesPassedToNativeCodeMustIncludeExceptionHandlingDescription {
            get {
                return ResourceManager.GetString("DelegatesPassedToNativeCodeMustIncludeExceptionHandlingDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; is used as a delegate passed to native code and must include a try-catch block that spans the entire method.
        /// </summary>
        internal static string DelegatesPassedToNativeCodeMustIncludeExceptionHandlingMessage {
            get {
                return ResourceManager.GetString("DelegatesPassedToNativeCodeMustIncludeExceptionHandlingMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delegate passed to native code must include exception handling.
        /// </summary>
        internal static string DelegatesPassedToNativeCodeMustIncludeExceptionHandlingTitle {
            get {
                return ResourceManager.GetString("DelegatesPassedToNativeCodeMustIncludeExceptionHandlingTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types with [OptionalField] should have methods decorated with [OnDeserialized] or [OnDeserializing] to properly initialize those fields during deserialization..
        /// </summary>
        internal static string DeserializeOptionalFieldDescription {
            get {
                return ResourceManager.GetString("DeserializeOptionalFieldDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; has [OptionalField] but no [OnDeserialized] or [OnDeserializing] method.
        /// </summary>
        internal static string DeserializeOptionalFieldMessage {
            get {
                return ResourceManager.GetString("DeserializeOptionalFieldMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Handle [OptionalField] during deserialization.
        /// </summary>
        internal static string DeserializeOptionalFieldTitle {
            get {
                return ResourceManager.GetString("DeserializeOptionalFieldTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-console applications should not contain calls to Console.WriteLine. Use Debug.WriteLine or Conditional(\&quot;DEBUG\&quot;) instead..
        /// </summary>
        internal static string DisableDebuggingCode_Description {
            get {
                return ResourceManager.GetString("DisableDebuggingCode_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The method &apos;{0}&apos; contains a call to Console.WriteLine.
        /// </summary>
        internal static string DisableDebuggingCode_Message {
            get {
                return ResourceManager.GetString("DisableDebuggingCode_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Disable debugging code in non-console applications.
        /// </summary>
        internal static string DisableDebuggingCode_Title {
            get {
                return ResourceManager.GetString("DisableDebuggingCode_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The rule inspects all fields for disposable types and checks that the type’s Dispose method calls Dispose on all disposable fields..
        /// </summary>
        internal static string DisposableFieldsShouldBeDisposed_Description {
            get {
                return ResourceManager.GetString("DisposableFieldsShouldBeDisposed_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field &apos;{0}&apos; is not disposed.
        /// </summary>
        internal static string DisposableFieldsShouldBeDisposed_Message {
            get {
                return ResourceManager.GetString("DisposableFieldsShouldBeDisposed_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Disposable fields should be disposed.
        /// </summary>
        internal static string DisposableFieldsShouldBeDisposed_Title {
            get {
                return ResourceManager.GetString("DisposableFieldsShouldBeDisposed_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule fires for types that implement IDisposable and contain native fields but have no finalizer..
        /// </summary>
        internal static string DisposableTypesShouldHaveFinalizerDescription {
            get {
                return ResourceManager.GetString("DisposableTypesShouldHaveFinalizerDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; implements IDisposable, has native resources, but does not define a finalizer..
        /// </summary>
        internal static string DisposableTypesShouldHaveFinalizerMessage {
            get {
                return ResourceManager.GetString("DisposableTypesShouldHaveFinalizerMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Disposable types should have a finalizer.
        /// </summary>
        internal static string DisposableTypesShouldHaveFinalizerTitle {
            get {
                return ResourceManager.GetString("DisposableTypesShouldHaveFinalizerTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid casting IntPtr or UIntPtr to 32-bit or smaller types; use Int64 or avoid casting to integer types..
        /// </summary>
        internal static string DoNotAssumeIntPtrSizeDescription {
            get {
                return ResourceManager.GetString("DoNotAssumeIntPtrSizeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Casting IntPtr to a 32-bit or smaller type can cause errors on 64-bit platforms.
        /// </summary>
        internal static string DoNotAssumeIntPtrSizeMessage {
            get {
                return ResourceManager.GetString("DoNotAssumeIntPtrSizeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not assume IntPtr size.
        /// </summary>
        internal static string DoNotAssumeIntPtrSizeTitle {
            get {
                return ResourceManager.GetString("DoNotAssumeIntPtrSizeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to As defined in IEEE 754 it’s impossible to compare any floating-point value, even another NaN, with NaN..
        /// </summary>
        internal static string DoNotCompareWithNaN_Description {
            get {
                return ResourceManager.GetString("DoNotCompareWithNaN_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Comparison with NaN always returns false.
        /// </summary>
        internal static string DoNotCompareWithNaN_Message {
            get {
                return ResourceManager.GetString("DoNotCompareWithNaN_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not compare with NaN.
        /// </summary>
        internal static string DoNotCompareWithNaN_Title {
            get {
                return ResourceManager.GetString("DoNotCompareWithNaN_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sealed types cannot be inherited from, so protected members are misleading and should be private..
        /// </summary>
        internal static string DoNotDeclareProtectedMembersInSealedTypeDescription {
            get {
                return ResourceManager.GetString("DoNotDeclareProtectedMembersInSealedTypeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sealed type &apos;{0}&apos; has protected member &apos;{1}&apos;..
        /// </summary>
        internal static string DoNotDeclareProtectedMembersInSealedTypeMessage {
            get {
                return ResourceManager.GetString("DoNotDeclareProtectedMembersInSealedTypeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not declare protected members in sealed types.
        /// </summary>
        internal static string DoNotDeclareProtectedMembersInSealedTypeTitle {
            get {
                return ResourceManager.GetString("DoNotDeclareProtectedMembersInSealedTypeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Virtual methods make sense only in types that can be inherited from..
        /// </summary>
        internal static string DoNotDeclareVirtualMethodsInSealedTypeDescription {
            get {
                return ResourceManager.GetString("DoNotDeclareVirtualMethodsInSealedTypeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sealed type &apos;{0}&apos; has a virtual method &apos;{1}&apos;..
        /// </summary>
        internal static string DoNotDeclareVirtualMethodsInSealedTypeMessage {
            get {
                return ResourceManager.GetString("DoNotDeclareVirtualMethodsInSealedTypeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not declare virtual methods in sealed types.
        /// </summary>
        internal static string DoNotDeclareVirtualMethodsInSealedTypeTitle {
            get {
                return ResourceManager.GetString("DoNotDeclareVirtualMethodsInSealedTypeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rethrowing exceptions using &apos;throw ex;&apos; resets the stack trace. Use &apos;throw;&apos; to preserve it..
        /// </summary>
        internal static string DoNotDestroyStackTraceDescription {
            get {
                return ResourceManager.GetString("DoNotDestroyStackTraceDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;throw;&apos; instead of &apos;throw ex;&apos; to preserve stack trace.
        /// </summary>
        internal static string DoNotDestroyStackTraceMessage {
            get {
                return ResourceManager.GetString("DoNotDestroyStackTraceMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not destroy stack trace when rethrowing exceptions.
        /// </summary>
        internal static string DoNotDestroyStackTraceTitle {
            get {
                return ResourceManager.GetString("DoNotDestroyStackTraceTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types secured by demands should not expose public fields, as access to these fields is not covered by the declarative demands, potentially leading to security vulnerabilities..
        /// </summary>
        internal static string DoNotExposeFieldsInSecuredTypeDescription {
            get {
                return ResourceManager.GetString("DoNotExposeFieldsInSecuredTypeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; has security demands but exposes public fields: {1}.
        /// </summary>
        internal static string DoNotExposeFieldsInSecuredTypeMessage {
            get {
                return ResourceManager.GetString("DoNotExposeFieldsInSecuredTypeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not expose fields in secured types.
        /// </summary>
        internal static string DoNotExposeFieldsInSecuredTypeTitle {
            get {
                return ResourceManager.GetString("DoNotExposeFieldsInSecuredTypeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Visible methods should not be less protected than the methods they call if the called methods are protected by a LinkDemand. This could allow bypassing security checks..
        /// </summary>
        internal static string DoNotExposeMethodsProtectedByLinkDemandDescription {
            get {
                return ResourceManager.GetString("DoNotExposeMethodsProtectedByLinkDemandDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; exposes a method protected by a LinkDemand with stricter permissions.
        /// </summary>
        internal static string DoNotExposeMethodsProtectedByLinkDemandMessage {
            get {
                return ResourceManager.GetString("DoNotExposeMethodsProtectedByLinkDemandMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not expose methods that bypass security by calling methods with stricter demands.
        /// </summary>
        internal static string DoNotExposeMethodsProtectedByLinkDemandTitle {
            get {
                return ResourceManager.GetString("DoNotExposeMethodsProtectedByLinkDemandTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Nested generic signatures should be avoided for publicly exposed methods, as they can be difficult to construct and understand..
        /// </summary>
        internal static string DoNotExposeNestedGenericSignatures_Description {
            get {
                return ResourceManager.GetString("DoNotExposeNestedGenericSignatures_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; exposes a nested generic signature.
        /// </summary>
        internal static string DoNotExposeNestedGenericSignatures_Message {
            get {
                return ResourceManager.GetString("DoNotExposeNestedGenericSignatures_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do Not Expose Nested Generic Signatures.
        /// </summary>
        internal static string DoNotExposeNestedGenericSignatures_Title {
            get {
                return ResourceManager.GetString("DoNotExposeNestedGenericSignatures_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods throwing NotImplementedException should be implemented before release..
        /// </summary>
        internal static string DoNotForgetNotImplementedMethods_Description {
            get {
                return ResourceManager.GetString("DoNotForgetNotImplementedMethods_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The method &apos;{0}&apos; throws a NotImplementedException.
        /// </summary>
        internal static string DoNotForgetNotImplementedMethods_Message {
            get {
                return ResourceManager.GetString("DoNotForgetNotImplementedMethods_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not forget NotImplemented methods.
        /// </summary>
        internal static string DoNotForgetNotImplementedMethods_Title {
            get {
                return ResourceManager.GetString("DoNotForgetNotImplementedMethods_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Strings containing hardcoded paths are not portable across operating systems. Use Path.Combine and/or Environment.GetFolderPath to ensure cross-platform functionality..
        /// </summary>
        internal static string DoNotHardcodePathsDescription {
            get {
                return ResourceManager.GetString("DoNotHardcodePathsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid hardcoding paths in code; use Path.Combine or Environment.GetFolderPath instead.
        /// </summary>
        internal static string DoNotHardcodePathsMessage {
            get {
                return ResourceManager.GetString("DoNotHardcodePathsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not hardcode paths.
        /// </summary>
        internal static string DoNotHardcodePathsTitle {
            get {
                return ResourceManager.GetString("DoNotHardcodePathsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ignoring the result of certain methods can lead to wasted resources and potential logic errors. Ensure that method results are used appropriately..
        /// </summary>
        internal static string DoNotIgnoreMethodResultDescription {
            get {
                return ResourceManager.GetString("DoNotIgnoreMethodResultDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The result of method &apos;{0}&apos; is ignored.
        /// </summary>
        internal static string DoNotIgnoreMethodResultMessage {
            get {
                return ResourceManager.GetString("DoNotIgnoreMethodResultMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not ignore method results.
        /// </summary>
        internal static string DoNotIgnoreMethodResultTitle {
            get {
                return ResourceManager.GetString("DoNotIgnoreMethodResultTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using &apos;lock (this)&apos; or &apos;lock (typeof(...))&apos; can cause deadlocks. Use a private lock object instead..
        /// </summary>
        internal static string DoNotLockOnThisOrTypesAnalyzer_Description {
            get {
                return ResourceManager.GetString("DoNotLockOnThisOrTypesAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not lock on &apos;this&apos; or &apos;Type&apos; to avoid deadlocks.
        /// </summary>
        internal static string DoNotLockOnThisOrTypesAnalyzer_Message {
            get {
                return ResourceManager.GetString("DoNotLockOnThisOrTypesAnalyzer_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not lock on &apos;this&apos; or &apos;Type&apos;.
        /// </summary>
        internal static string DoNotLockOnThisOrTypesAnalyzer_Title {
            get {
                return ResourceManager.GetString("DoNotLockOnThisOrTypesAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locking on objects with weak identity (e.g., strings, exceptions) can cause deadlocks. Use a private lock object instead..
        /// </summary>
        internal static string DoNotLockOnWeakIdentityObjectsAnalyzer_Description {
            get {
                return ResourceManager.GetString("DoNotLockOnWeakIdentityObjectsAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not lock on objects with weak identity to avoid deadlocks.
        /// </summary>
        internal static string DoNotLockOnWeakIdentityObjectsAnalyzer_Message {
            get {
                return ResourceManager.GetString("DoNotLockOnWeakIdentityObjectsAnalyzer_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not lock on objects with weak identity.
        /// </summary>
        internal static string DoNotLockOnWeakIdentityObjectsAnalyzer_Title {
            get {
                return ResourceManager.GetString("DoNotLockOnWeakIdentityObjectsAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Event names should use verbs in the present or past tense, not prefixes like &apos;After&apos; or &apos;Before&apos;..
        /// </summary>
        internal static string DoNotPrefixEventsWithAfterOrBeforeDescription {
            get {
                return ResourceManager.GetString("DoNotPrefixEventsWithAfterOrBeforeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Event &apos;{0}&apos; is prefixed with &apos;After&apos; or &apos;Before&apos;.
        /// </summary>
        internal static string DoNotPrefixEventsWithAfterOrBeforeMessage {
            get {
                return ResourceManager.GetString("DoNotPrefixEventsWithAfterOrBeforeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not prefix events with &apos;After&apos; or &apos;Before&apos;.
        /// </summary>
        internal static string DoNotPrefixEventsWithAfterOrBeforeTitle {
            get {
                return ResourceManager.GetString("DoNotPrefixEventsWithAfterOrBeforeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum values should not include the enum type name as a prefix to avoid redundancy..
        /// </summary>
        internal static string DoNotPrefixValuesWithEnumNameDescription {
            get {
                return ResourceManager.GetString("DoNotPrefixValuesWithEnumNameDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum value &apos;{0}&apos; is prefixed with its enum type name &apos;{1}&apos;.
        /// </summary>
        internal static string DoNotPrefixValuesWithEnumNameMessage {
            get {
                return ResourceManager.GetString("DoNotPrefixValuesWithEnumNameMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not prefix enum values with enum type name.
        /// </summary>
        internal static string DoNotPrefixValuesWithEnumNameTitle {
            get {
                return ResourceManager.GetString("DoNotPrefixValuesWithEnumNameTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An equality operator (==) orinequality operator (!=) method is calling itself recursively..
        /// </summary>
        internal static string DoNotRecurseInEquality_Description {
            get {
                return ResourceManager.GetString("DoNotRecurseInEquality_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Equality operator calls itself recursively.
        /// </summary>
        internal static string DoNotRecurseInEquality_Message {
            get {
                return ResourceManager.GetString("DoNotRecurseInEquality_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not recurse in equality operator.
        /// </summary>
        internal static string DoNotRecurseInEquality_Title {
            get {
                return ResourceManager.GetString("DoNotRecurseInEquality_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods in a secured type should not have security permissions that are not a subset of the type&apos;s permissions, as this can create security vulnerabilities..
        /// </summary>
        internal static string DoNotReduceTypeSecurityOnMethodsDescription {
            get {
                return ResourceManager.GetString("DoNotReduceTypeSecurityOnMethodsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; has security demands that are not a subset of the type&apos;s demands.
        /// </summary>
        internal static string DoNotReduceTypeSecurityOnMethodsMessage {
            get {
                return ResourceManager.GetString("DoNotReduceTypeSecurityOnMethodsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not reduce type security on methods.
        /// </summary>
        internal static string DoNotReduceTypeSecurityOnMethodsTitle {
            get {
                return ResourceManager.GetString("DoNotReduceTypeSecurityOnMethodsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for attempts to call Round, Ceiling, Floor or Truncate on an integral type..
        /// </summary>
        internal static string DoNotRoundIntegers_Description {
            get {
                return ResourceManager.GetString("DoNotRoundIntegers_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rounding operation on an integer is redundant.
        /// </summary>
        internal static string DoNotRoundIntegers_Message {
            get {
                return ResourceManager.GetString("DoNotRoundIntegers_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not round integers.
        /// </summary>
        internal static string DoNotRoundIntegers_Title {
            get {
                return ResourceManager.GetString("DoNotRoundIntegers_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Overriding certificate validation to accept all certificates disables critical security checks, making the application vulnerable to man-in-the-middle attacks..
        /// </summary>
        internal static string DoNotShortCircuitCertificateCheckDescription {
            get {
                return ResourceManager.GetString("DoNotShortCircuitCertificateCheckDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Certificate validation callback &apos;{0}&apos; should not unconditionally accept certificates.
        /// </summary>
        internal static string DoNotShortCircuitCertificateCheckMessage {
            get {
                return ResourceManager.GetString("DoNotShortCircuitCertificateCheckMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not short-circuit certificate checks.
        /// </summary>
        internal static string DoNotShortCircuitCertificateCheckTitle {
            get {
                return ResourceManager.GetString("DoNotShortCircuitCertificateCheckTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Catch specific exceptions or rethrow to avoid swallowing errors.
        /// </summary>
        internal static string DoNotSwallowErrorsCatchingNonSpecificExceptionsDescription {
            get {
                return ResourceManager.GetString("DoNotSwallowErrorsCatchingNonSpecificExceptionsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Catching non-specific exceptions without rethrowing can swallow errors.
        /// </summary>
        internal static string DoNotSwallowErrorsCatchingNonSpecificExceptionsMessage {
            get {
                return ResourceManager.GetString("DoNotSwallowErrorsCatchingNonSpecificExceptionsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid swallowing exceptions by catching non-specific exceptions.
        /// </summary>
        internal static string DoNotSwallowErrorsCatchingNonSpecificExceptionsTitle {
            get {
                return ResourceManager.GetString("DoNotSwallowErrorsCatchingNonSpecificExceptionsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods like Equals, GetHashCode, ToString, Dispose, and finalizers should not throw exceptions.
        /// </summary>
        internal static string DoNotThrowInUnexpectedLocationDescription {
            get {
                return ResourceManager.GetString("DoNotThrowInUnexpectedLocationDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not throw exceptions in method &apos;{0}&apos; as it is unexpected.
        /// </summary>
        internal static string DoNotThrowInUnexpectedLocationMessage {
            get {
                return ResourceManager.GetString("DoNotThrowInUnexpectedLocationMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid throwing exceptions in unexpected locations.
        /// </summary>
        internal static string DoNotThrowInUnexpectedLocationTitle {
            get {
                return ResourceManager.GetString("DoNotThrowInUnexpectedLocationTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Throwing reserved exceptions can cause unexpected behavior; use appropriate exception types.
        /// </summary>
        internal static string DoNotThrowReservedExceptionDescription {
            get {
                return ResourceManager.GetString("DoNotThrowReservedExceptionDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not throw &apos;{0}&apos;; it is reserved for use by the runtime.
        /// </summary>
        internal static string DoNotThrowReservedExceptionMessage {
            get {
                return ResourceManager.GetString("DoNotThrowReservedExceptionMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid throwing reserved exceptions.
        /// </summary>
        internal static string DoNotThrowReservedExceptionTitle {
            get {
                return ResourceManager.GetString("DoNotThrowReservedExceptionTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Calls to typeof(Enum).IsAssignableFrom(type) can be simplified to type.IsEnum..
        /// </summary>
        internal static string DoNotUseEnumIsAssignableFrom_Description {
            get {
                return ResourceManager.GetString("DoNotUseEnumIsAssignableFrom_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace &apos;typeof(Enum).IsAssignableFrom({0})&apos; with &apos;{0}.IsEnum&apos;.
        /// </summary>
        internal static string DoNotUseEnumIsAssignableFrom_Message {
            get {
                return ResourceManager.GetString("DoNotUseEnumIsAssignableFrom_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use type.IsEnum instead of typeof(Enum).IsAssignableFrom(type).
        /// </summary>
        internal static string DoNotUseEnumIsAssignableFrom_Title {
            get {
                return ResourceManager.GetString("DoNotUseEnumIsAssignableFrom_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Calls to Type.GetInterface to check if a type supports an interface should be replaced with typeof(interface).IsAssignableFrom(type)..
        /// </summary>
        internal static string DoNotUseGetInterfaceToCheckAssignability_Description {
            get {
                return ResourceManager.GetString("DoNotUseGetInterfaceToCheckAssignability_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace &apos;type.GetInterface(&quot;{0}&quot;) != null&apos; with &apos;typeof({0}).IsAssignableFrom(type)&apos;.
        /// </summary>
        internal static string DoNotUseGetInterfaceToCheckAssignability_Message {
            get {
                return ResourceManager.GetString("DoNotUseGetInterfaceToCheckAssignability_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not use GetInterface to check assignability.
        /// </summary>
        internal static string DoNotUseGetInterfaceToCheckAssignability_Title {
            get {
                return ResourceManager.GetString("DoNotUseGetInterfaceToCheckAssignability_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using Monitor.Enter without Monitor.Exit in the same method can lead to deadlocks and is difficult to maintain..
        /// </summary>
        internal static string DoNotUseLockedRegionOutsideMethodAnalyzer_Description {
            get {
                return ResourceManager.GetString("DoNotUseLockedRegionOutsideMethodAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not use Monitor.Enter without corresponding Monitor.Exit in the same method.
        /// </summary>
        internal static string DoNotUseLockedRegionOutsideMethodAnalyzer_Message {
            get {
                return ResourceManager.GetString("DoNotUseLockedRegionOutsideMethodAnalyzer_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not use locked region outside method.
        /// </summary>
        internal static string DoNotUseLockedRegionOutsideMethodAnalyzer_Title {
            get {
                return ResourceManager.GetString("DoNotUseLockedRegionOutsideMethodAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using MethodImplOptions.Synchronized causes a lock(this) or lock(typeof(...)) which can cause deadlocks. Use a private lock object instead..
        /// </summary>
        internal static string DoNotUseMethodImplOptionsSynchronizedAnalyzer_Description {
            get {
                return ResourceManager.GetString("DoNotUseMethodImplOptionsSynchronizedAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not use MethodImplOptions.Synchronized on method &apos;{0}&apos;.
        /// </summary>
        internal static string DoNotUseMethodImplOptionsSynchronizedAnalyzer_Message {
            get {
                return ResourceManager.GetString("DoNotUseMethodImplOptionsSynchronizedAnalyzer_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not use MethodImplOptions.Synchronized.
        /// </summary>
        internal static string DoNotUseMethodImplOptionsSynchronizedAnalyzer_Title {
            get {
                return ResourceManager.GetString("DoNotUseMethodImplOptionsSynchronizedAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using &apos;Reserved&apos; in enum values can lead to breaking changes when modifying the enum. It&apos;s better to add new meaningful values as needed..
        /// </summary>
        internal static string DoNotUseReservedInEnumValueNamesDescription {
            get {
                return ResourceManager.GetString("DoNotUseReservedInEnumValueNamesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum &apos;{1}&apos; contains a value named &apos;{0}&apos;, which should be avoided.
        /// </summary>
        internal static string DoNotUseReservedInEnumValueNamesMessage {
            get {
                return ResourceManager.GetString("DoNotUseReservedInEnumValueNamesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not use &apos;Reserved&apos; in enum value names.
        /// </summary>
        internal static string DoNotUseReservedInEnumValueNamesTitle {
            get {
                return ResourceManager.GetString("DoNotUseReservedInEnumValueNamesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The ThreadStatic attribute can only be applied to static fields. Applying it to instance fields is ineffective..
        /// </summary>
        internal static string DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Description {
            get {
                return ResourceManager.GetString("DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The field &apos;{0}&apos; is an instance field with the ThreadStatic attribute, which is ineffective.
        /// </summary>
        internal static string DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Message {
            get {
                return ResourceManager.GetString("DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not use ThreadStatic attribute with instance fields.
        /// </summary>
        internal static string DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Title {
            get {
                return ResourceManager.GetString("DoNotUseThreadStaticWithInstanceFieldsAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Double-check locking can be problematic in older versions of .NET. Ensure it is used correctly..
        /// </summary>
        internal static string DoubleCheckLockingAnalyzer_Description {
            get {
                return ResourceManager.GetString("DoubleCheckLockingAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid double-check locking on &apos;{0}&apos;.
        /// </summary>
        internal static string DoubleCheckLockingAnalyzer_Message {
            get {
                return ResourceManager.GetString("DoubleCheckLockingAnalyzer_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid double-check locking.
        /// </summary>
        internal static string DoubleCheckLockingAnalyzer_Title {
            get {
                return ResourceManager.GetString("DoubleCheckLockingAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks that disposable locals are always disposed of before the method returns..
        /// </summary>
        internal static string EnsureLocalDisposal_Description {
            get {
                return ResourceManager.GetString("EnsureLocalDisposal_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Local disposable object &apos;{0}&apos; is not disposed.
        /// </summary>
        internal static string EnsureLocalDisposal_Message {
            get {
                return ResourceManager.GetString("EnsureLocalDisposal_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure local disposal.
        /// </summary>
        internal static string EnsureLocalDisposal_Title {
            get {
                return ResourceManager.GetString("EnsureLocalDisposal_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for operators that are not overloaded in pairs (e.g. &apos;+&apos; without &apos;-&apos;)..
        /// </summary>
        internal static string EnsureSymmetryForOverloadedOperatorsDescription {
            get {
                return ResourceManager.GetString("EnsureSymmetryForOverloadedOperatorsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; overloads operator &apos;{1}&apos; but not the complementary operator..
        /// </summary>
        internal static string EnsureSymmetryForOverloadedOperatorsMessage {
            get {
                return ResourceManager.GetString("EnsureSymmetryForOverloadedOperatorsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure symmetry for overloaded operators.
        /// </summary>
        internal static string EnsureSymmetryForOverloadedOperatorsTitle {
            get {
                return ResourceManager.GetString("EnsureSymmetryForOverloadedOperatorsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks that every non-flags enum has a zero value for proper default initialization..
        /// </summary>
        internal static string EnumsShouldDefineAZeroValueDescription {
            get {
                return ResourceManager.GetString("EnumsShouldDefineAZeroValueDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum &apos;{0}&apos; does not define a zero value..
        /// </summary>
        internal static string EnumsShouldDefineAZeroValueMessage {
            get {
                return ResourceManager.GetString("EnumsShouldDefineAZeroValueMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enums should define a zero value.
        /// </summary>
        internal static string EnumsShouldDefineAZeroValueTitle {
            get {
                return ResourceManager.GetString("EnumsShouldDefineAZeroValueTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enumaration types should avoid specifying a non-default storage type unless it is required for interoperability..
        /// </summary>
        internal static string EnumsShouldUseInt32Description {
            get {
                return ResourceManager.GetString("EnumsShouldUseInt32Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum &apos;{0}&apos; uses a non-Int32 underlying type. Consider using int unless there&apos;s a compelling interoperability reason..
        /// </summary>
        internal static string EnumsShouldUseInt32Message {
            get {
                return ResourceManager.GetString("EnumsShouldUseInt32Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enums should use Int32 by default.
        /// </summary>
        internal static string EnumsShouldUseInt32Title {
            get {
                return ResourceManager.GetString("EnumsShouldUseInt32Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Equals(object) methods should return false when the object parameter is null..
        /// </summary>
        internal static string EqualsShouldHandleNullArg_Description {
            get {
                return ResourceManager.GetString("EqualsShouldHandleNullArg_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Equals method does not handle null argument.
        /// </summary>
        internal static string EqualsShouldHandleNullArg_Message {
            get {
                return ResourceManager.GetString("EqualsShouldHandleNullArg_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Equals method should handle null argument.
        /// </summary>
        internal static string EqualsShouldHandleNullArg_Title {
            get {
                return ResourceManager.GetString("EqualsShouldHandleNullArg_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-public exception types derived directly from basic exceptions do not provide sufficient information to consumers.
        /// </summary>
        internal static string ExceptionShouldBeVisibleDescription {
            get {
                return ResourceManager.GetString("ExceptionShouldBeVisibleDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exception type &apos;{0}&apos; should be public to be meaningful to API consumers.
        /// </summary>
        internal static string ExceptionShouldBeVisibleMessage {
            get {
                return ResourceManager.GetString("ExceptionShouldBeVisibleMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exception types should be public.
        /// </summary>
        internal static string ExceptionShouldBeVisibleTitle {
            get {
                return ResourceManager.GetString("ExceptionShouldBeVisibleTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On Unix systems, process exit codes must be between 0 and 255. Ensure that returned values and Environment.ExitCode are within this range..
        /// </summary>
        internal static string ExitCodeIsLimitedOnUnixDescription {
            get {
                return ResourceManager.GetString("ExitCodeIsLimitedOnUnixDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Process exit codes must be between 0 and 255 on Unix systems.
        /// </summary>
        internal static string ExitCodeIsLimitedOnUnixMessage {
            get {
                return ResourceManager.GetString("ExitCodeIsLimitedOnUnixMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Limit exit codes to 0-255 on Unix.
        /// </summary>
        internal static string ExitCodeIsLimitedOnUnixTitle {
            get {
                return ResourceManager.GetString("ExitCodeIsLimitedOnUnixTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Certain features require root privilege on Unix systems. Ensure that code using such features handles privilege requirements appropriately..
        /// </summary>
        internal static string FeatureRequiresRootPrivilegeOnUnixDescription {
            get {
                return ResourceManager.GetString("FeatureRequiresRootPrivilegeOnUnixDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This feature requires root privilege on Unix systems.
        /// </summary>
        internal static string FeatureRequiresRootPrivilegeOnUnixMessage {
            get {
                return ResourceManager.GetString("FeatureRequiresRootPrivilegeOnUnixMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Feature requires root privilege on Unix.
        /// </summary>
        internal static string FeatureRequiresRootPrivilegeOnUnixTitle {
            get {
                return ResourceManager.GetString("FeatureRequiresRootPrivilegeOnUnixTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Finalizers must be accessible only to the type’s family (protected in C#)..
        /// </summary>
        internal static string FinalizersShouldBeProtectedDescription {
            get {
                return ResourceManager.GetString("FinalizersShouldBeProtectedDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; has a finalizer with non-family accessibility..
        /// </summary>
        internal static string FinalizersShouldBeProtectedMessage {
            get {
                return ResourceManager.GetString("FinalizersShouldBeProtectedMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Finalizers should be protected.
        /// </summary>
        internal static string FinalizersShouldBeProtectedTitle {
            get {
                return ResourceManager.GetString("FinalizersShouldBeProtectedTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks that a finalizer calls the base class finalizer..
        /// </summary>
        internal static string FinalizersShouldCallBaseClassFinalizer_Description {
            get {
                return ResourceManager.GetString("FinalizersShouldCallBaseClassFinalizer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Finalizer does not call the base class finalizer.
        /// </summary>
        internal static string FinalizersShouldCallBaseClassFinalizer_Message {
            get {
                return ResourceManager.GetString("FinalizersShouldCallBaseClassFinalizer_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Finalizers should call base class finalizer.
        /// </summary>
        internal static string FinalizersShouldCallBaseClassFinalizer_Title {
            get {
                return ResourceManager.GetString("FinalizersShouldCallBaseClassFinalizer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enumerations decorated with [Flags] should not define a zero value. This value would not be usable with bitwise operators..
        /// </summary>
        internal static string FlagsShouldNotDefineAZeroValueDescription {
            get {
                return ResourceManager.GetString("FlagsShouldNotDefineAZeroValueDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum &apos;{0}&apos; is marked with [Flags] but defines a zero value, which is not recommended..
        /// </summary>
        internal static string FlagsShouldNotDefineAZeroValueMessage {
            get {
                return ResourceManager.GetString("FlagsShouldNotDefineAZeroValueMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Flags enum should not define a zero value.
        /// </summary>
        internal static string FlagsShouldNotDefineAZeroValueTitle {
            get {
                return ResourceManager.GetString("FlagsShouldNotDefineAZeroValueTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Calls to Assembly.GetEntryAssembly() may return null in libraries or DLLs. Ensure proper null handling..
        /// </summary>
        internal static string GetEntryAssemblyMayReturnNull_Description {
            get {
                return ResourceManager.GetString("GetEntryAssemblyMayReturnNull_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assembly.GetEntryAssembly may return null when called from a library or DLL.
        /// </summary>
        internal static string GetEntryAssemblyMayReturnNull_Message {
            get {
                return ResourceManager.GetString("GetEntryAssemblyMayReturnNull_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assembly.GetEntryAssembly may return null.
        /// </summary>
        internal static string GetEntryAssemblyMayReturnNull_Title {
            get {
                return ResourceManager.GetString("GetEntryAssemblyMayReturnNull_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Calling other managed methods before GetLastWin32Error may overwrite the error code..
        /// </summary>
        internal static string GetLastErrorMustBeCalledRightAfterPInvokeDescription {
            get {
                return ResourceManager.GetString("GetLastErrorMustBeCalledRightAfterPInvokeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Marshal.GetLastWin32Error should be called immediately after a P/Invoke call to avoid overwriting the error code.
        /// </summary>
        internal static string GetLastErrorMustBeCalledRightAfterPInvokeMessage {
            get {
                return ResourceManager.GetString("GetLastErrorMustBeCalledRightAfterPInvokeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GetLastWin32Error must be called immediately after P/Invoke.
        /// </summary>
        internal static string GetLastErrorMustBeCalledRightAfterPInvokeTitle {
            get {
                return ResourceManager.GetString("GetLastErrorMustBeCalledRightAfterPInvokeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An executable assembly referencing GtkSharp should be compiled with -target:winexe to prevent a console window from appearing under Windows..
        /// </summary>
        internal static string GtkSharpExecutableTargetDescription {
            get {
                return ResourceManager.GetString("GtkSharpExecutableTargetDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Executable assembly references GtkSharp but is not compiled with -target:winexe.
        /// </summary>
        internal static string GtkSharpExecutableTargetMessage {
            get {
                return ResourceManager.GetString("GtkSharpExecutableTargetMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Executable referencing GtkSharp should use Windows subsystem.
        /// </summary>
        internal static string GtkSharpExecutableTargetTitle {
            get {
                return ResourceManager.GetString("GtkSharpExecutableTargetTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks that if a type overrides Equals(object), it also overrides GetHashCode(), and vice versa..
        /// </summary>
        internal static string ImplementEqualsAndGetHashCodeInPairDescription {
            get {
                return ResourceManager.GetString("ImplementEqualsAndGetHashCodeInPairDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; overrides &apos;{1}&apos; but not &apos;{2}&apos;. Both should be overridden together..
        /// </summary>
        internal static string ImplementEqualsAndGetHashCodeInPairMessage {
            get {
                return ResourceManager.GetString("ImplementEqualsAndGetHashCodeInPairMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement Equals and GetHashCode in pairs.
        /// </summary>
        internal static string ImplementEqualsAndGetHashCodeInPairTitle {
            get {
                return ResourceManager.GetString("ImplementEqualsAndGetHashCodeInPairTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implementing a type-specific Equals method and IEquatable&lt;T&gt; improves performance and usability, especially for value types..
        /// </summary>
        internal static string ImplementEqualsTypeDescription {
            get {
                return ResourceManager.GetString("ImplementEqualsTypeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; overrides Equals(object) but does not implement Equals({0}) or IEquatable&lt;{0}&gt;.
        /// </summary>
        internal static string ImplementEqualsTypeMessage {
            get {
                return ResourceManager.GetString("ImplementEqualsTypeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement type-specific Equals method and IEquatable&lt;T&gt;.
        /// </summary>
        internal static string ImplementEqualsTypeTitle {
            get {
                return ResourceManager.GetString("ImplementEqualsTypeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implementing &apos;IEnumerable&lt;T&gt;&apos; helps avoid type casting and ensures type safety during iteration..
        /// </summary>
        internal static string ImplementGenericCollectionInterfaces_Description {
            get {
                return ResourceManager.GetString("ImplementGenericCollectionInterfaces_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider implementing &apos;IEnumerable&lt;T&gt;&apos; instead of &apos;IEnumerable&apos; for type safety and improved usability.
        /// </summary>
        internal static string ImplementGenericCollectionInterfaces_Message {
            get {
                return ResourceManager.GetString("ImplementGenericCollectionInterfaces_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement Generic Collection Interfaces.
        /// </summary>
        internal static string ImplementGenericCollectionInterfaces_Title {
            get {
                return ResourceManager.GetString("ImplementGenericCollectionInterfaces_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If a method named &apos;Clone()&apos; returns object, it should implement System.ICloneable; or else return a strongly typed value..
        /// </summary>
        internal static string ImplementICloneableCorrectlyDescription {
            get {
                return ResourceManager.GetString("ImplementICloneableCorrectlyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; declares a &apos;Clone()&apos; method returning System.Object but does not implement ICloneable..
        /// </summary>
        internal static string ImplementICloneableCorrectlyMessage {
            get {
                return ResourceManager.GetString("ImplementICloneableCorrectlyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement ICloneable correctly.
        /// </summary>
        internal static string ImplementICloneableCorrectlyTitle {
            get {
                return ResourceManager.GetString("ImplementICloneableCorrectlyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types that implement IComparable should also override Equals(object) and provide operator overloads ==, !=, &lt;, &gt;..
        /// </summary>
        internal static string ImplementIComparableCorrectlyDescription {
            get {
                return ResourceManager.GetString("ImplementIComparableCorrectlyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; implements IComparable but does not fully implement or override comparison members: {1}.
        /// </summary>
        internal static string ImplementIComparableCorrectlyMessage {
            get {
                return ResourceManager.GetString("ImplementIComparableCorrectlyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement IComparable correctly.
        /// </summary>
        internal static string ImplementIComparableCorrectlyTitle {
            get {
                return ResourceManager.GetString("ImplementIComparableCorrectlyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types implementing ISerializable should serialize all instance fields not marked with [NonSerialized], and GetObjectData should be virtual if the type is not sealed..
        /// </summary>
        internal static string ImplementISerializableCorrectlyDescription {
            get {
                return ResourceManager.GetString("ImplementISerializableCorrectlyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; does not implement ISerializable correctly.
        /// </summary>
        internal static string ImplementISerializableCorrectlyMessage {
            get {
                return ResourceManager.GetString("ImplementISerializableCorrectlyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement ISerializable correctly.
        /// </summary>
        internal static string ImplementISerializableCorrectlyTitle {
            get {
                return ResourceManager.GetString("ImplementISerializableCorrectlyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that the parameter name and message are provided in the correct order when throwing argument exceptions..
        /// </summary>
        internal static string InstantiateArgumentExceptionCorrectlyDescription {
            get {
                return ResourceManager.GetString("InstantiateArgumentExceptionCorrectlyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameters to &apos;{0}&apos; constructor are in the wrong order.
        /// </summary>
        internal static string InstantiateArgumentExceptionCorrectlyMessage {
            get {
                return ResourceManager.GetString("InstantiateArgumentExceptionCorrectlyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Instantiate argument exceptions correctly.
        /// </summary>
        internal static string InstantiateArgumentExceptionCorrectlyTitle {
            get {
                return ResourceManager.GetString("InstantiateArgumentExceptionCorrectlyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Namespaces ending with &apos;Internal&apos; or &apos;Impl&apos; should not expose public or protected types to external assemblies..
        /// </summary>
        internal static string InternalNamespacesShouldNotExposeTypesDescription {
            get {
                return ResourceManager.GetString("InternalNamespacesShouldNotExposeTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; is publicly visible but in an internal namespace &apos;{1}&apos;..
        /// </summary>
        internal static string InternalNamespacesShouldNotExposeTypesMessage {
            get {
                return ResourceManager.GetString("InternalNamespacesShouldNotExposeTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Internal namespace should not expose public types.
        /// </summary>
        internal static string InternalNamespacesShouldNotExposeTypesTitle {
            get {
                return ResourceManager.GetString("InternalNamespacesShouldNotExposeTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is better to make the entry point method non-public so that only the CLR can call it..
        /// </summary>
        internal static string MainShouldNotBePublicDescription {
            get {
                return ResourceManager.GetString("MainShouldNotBePublicDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Entry point method &apos;{0}&apos; is publicly visible. Consider changing its accessibility to private or internal..
        /// </summary>
        internal static string MainShouldNotBePublicMessage {
            get {
                return ResourceManager.GetString("MainShouldNotBePublicMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Main method should not be public.
        /// </summary>
        internal static string MainShouldNotBePublicTitle {
            get {
                return ResourceManager.GetString("MainShouldNotBePublicTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fields of serializable types must be serializable or marked with [NonSerialized]..
        /// </summary>
        internal static string MarkAllNonSerializableFieldsDescription {
            get {
                return ResourceManager.GetString("MarkAllNonSerializableFieldsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field &apos;{0}&apos; in serializable type &apos;{1}&apos; is not serializable.
        /// </summary>
        internal static string MarkAllNonSerializableFieldsMessage {
            get {
                return ResourceManager.GetString("MarkAllNonSerializableFieldsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark all non-serializable fields with [NonSerialized].
        /// </summary>
        internal static string MarkAllNonSerializableFieldsTitle {
            get {
                return ResourceManager.GetString("MarkAllNonSerializableFieldsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assemblies should define an [AssemblyVersion(&quot;x.y.z.w&quot;)] attribute for proper versioning..
        /// </summary>
        internal static string MarkAssemblyWithAssemblyVersionDescription {
            get {
                return ResourceManager.GetString("MarkAssemblyWithAssemblyVersionDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assembly &apos;{0}&apos; does not have an [AssemblyVersion] attribute..
        /// </summary>
        internal static string MarkAssemblyWithAssemblyVersionMessage {
            get {
                return ResourceManager.GetString("MarkAssemblyWithAssemblyVersionMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assembly with [AssemblyVersion].
        /// </summary>
        internal static string MarkAssemblyWithAssemblyVersionTitle {
            get {
                return ResourceManager.GetString("MarkAssemblyWithAssemblyVersionTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is a good practice to declare assemblies as CLS-compliant unless there&apos;s a reason not to..
        /// </summary>
        internal static string MarkAssemblyWithClsCompliantDescription {
            get {
                return ResourceManager.GetString("MarkAssemblyWithClsCompliantDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assembly &apos;{0}&apos; does not have a [CLSCompliant] attribute..
        /// </summary>
        internal static string MarkAssemblyWithClsCompliantMessage {
            get {
                return ResourceManager.GetString("MarkAssemblyWithClsCompliantMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assembly with [CLSCompliant].
        /// </summary>
        internal static string MarkAssemblyWithClsCompliantTitle {
            get {
                return ResourceManager.GetString("MarkAssemblyWithClsCompliantTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If the assembly is not designed for COM interop, mark it with [ComVisible(false)]..
        /// </summary>
        internal static string MarkAssemblyWithComVisibleDescription {
            get {
                return ResourceManager.GetString("MarkAssemblyWithComVisibleDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assembly &apos;{0}&apos; does not have a [ComVisible] attribute..
        /// </summary>
        internal static string MarkAssemblyWithComVisibleMessage {
            get {
                return ResourceManager.GetString("MarkAssemblyWithComVisibleMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assembly with [ComVisible].
        /// </summary>
        internal static string MarkAssemblyWithComVisibleTitle {
            get {
                return ResourceManager.GetString("MarkAssemblyWithComVisibleTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Even though enums are serializable by default, marking them with [Serializable] improves code readability..
        /// </summary>
        internal static string MarkEnumerationsAsSerializableDescription {
            get {
                return ResourceManager.GetString("MarkEnumerationsAsSerializableDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum &apos;{0}&apos; is not marked as [Serializable].
        /// </summary>
        internal static string MarkEnumerationsAsSerializableMessage {
            get {
                return ResourceManager.GetString("MarkEnumerationsAsSerializableMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark enumerations as [Serializable].
        /// </summary>
        internal static string MarkEnumerationsAsSerializableTitle {
            get {
                return ResourceManager.GetString("MarkEnumerationsAsSerializableTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Specify the [MarshalAs] attribute for boolean parameters in P/Invoke declarations to ensure correct size across platforms..
        /// </summary>
        internal static string MarshalBooleansInPInvokeDeclarationsDescription {
            get {
                return ResourceManager.GetString("MarshalBooleansInPInvokeDeclarationsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Boolean parameter &apos;{0}&apos; in P/Invoke should have an explicit [MarshalAs] attribute.
        /// </summary>
        internal static string MarshalBooleansInPInvokeDeclarationsMessage {
            get {
                return ResourceManager.GetString("MarshalBooleansInPInvokeDeclarationsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Booleans in P/Invoke signatures should be explicitly marshaled.
        /// </summary>
        internal static string MarshalBooleansInPInvokeDeclarationsTitle {
            get {
                return ResourceManager.GetString("MarshalBooleansInPInvokeDeclarationsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Specify the CharSet in DllImport or use [MarshalAs] for string parameters in P/Invoke declarations to ensure correct string marshaling across platforms.
        /// </summary>
        internal static string MarshalStringsInPInvokeDeclarationsDescription {
            get {
                return ResourceManager.GetString("MarshalStringsInPInvokeDeclarationsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to String parameter &apos;{0}&apos; in P/Invoke should specify CharSet in DllImport or have an explicit [MarshalAs] attribute.
        /// </summary>
        internal static string MarshalStringsInPInvokeDeclarationsMessage {
            get {
                return ResourceManager.GetString("MarshalStringsInPInvokeDeclarationsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Strings in P/Invoke signatures should specify CharSet or [MarshalAs].
        /// </summary>
        internal static string MarshalStringsInPInvokeDeclarationsTitle {
            get {
                return ResourceManager.GetString("MarshalStringsInPInvokeDeclarationsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using Math.Min or Math.Max can lead to better performance and clearer code compared to custom implementations..
        /// </summary>
        internal static string MathMinMaxCandidateDescription {
            get {
                return ResourceManager.GetString("MathMinMaxCandidateDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expression can be simplified using &apos;Math.{0}&apos;.
        /// </summary>
        internal static string MathMinMaxCandidateMessage {
            get {
                return ResourceManager.GetString("MathMinMaxCandidateMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Math.Min and Math.Max methods.
        /// </summary>
        internal static string MathMinMaxCandidateTitle {
            get {
                return ResourceManager.GetString("MathMinMaxCandidateTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for methods that do not require anything from the current instance and can be converted into static methods..
        /// </summary>
        internal static string MethodCanBeMadeStatic_Description {
            get {
                return ResourceManager.GetString("MethodCanBeMadeStatic_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; can be made static.
        /// </summary>
        internal static string MethodCanBeMadeStatic_Message {
            get {
                return ResourceManager.GetString("MethodCanBeMadeStatic_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method can be made static.
        /// </summary>
        internal static string MethodCanBeMadeStatic_Title {
            get {
                return ResourceManager.GetString("MethodCanBeMadeStatic_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Every custom attribute should have an [AttributeUsage(...)] to indicate valid targets..
        /// </summary>
        internal static string MissingAttributeUsageOnCustomAttributeDescription {
            get {
                return ResourceManager.GetString("MissingAttributeUsageOnCustomAttributeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom attribute &apos;{0}&apos; is not decorated with an [AttributeUsage] attribute..
        /// </summary>
        internal static string MissingAttributeUsageOnCustomAttributeMessage {
            get {
                return ResourceManager.GetString("MissingAttributeUsageOnCustomAttributeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Missing [AttributeUsage] on custom attribute.
        /// </summary>
        internal static string MissingAttributeUsageOnCustomAttributeTitle {
            get {
                return ResourceManager.GetString("MissingAttributeUsageOnCustomAttributeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that exception types implement the standard exception constructors for proper serialization and usage..
        /// </summary>
        internal static string MissingExceptionConstructorsDescription {
            get {
                return ResourceManager.GetString("MissingExceptionConstructorsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exception type &apos;{0}&apos; is missing one or more required constructors.
        /// </summary>
        internal static string MissingExceptionConstructorsMessage {
            get {
                return ResourceManager.GetString("MissingExceptionConstructorsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exception types should implement standard exception constructors.
        /// </summary>
        internal static string MissingExceptionConstructorsTitle {
            get {
                return ResourceManager.GetString("MissingExceptionConstructorsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types implementing ISerializable must be marked with the [Serializable] attribute to be serializable by the runtime..
        /// </summary>
        internal static string MissingSerializableAttributeOnISerializableTypeDescription {
            get {
                return ResourceManager.GetString("MissingSerializableAttributeOnISerializableTypeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; implements ISerializable but is not marked as [Serializable].
        /// </summary>
        internal static string MissingSerializableAttributeOnISerializableTypeMessage {
            get {
                return ResourceManager.GetString("MissingSerializableAttributeOnISerializableTypeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Missing [Serializable] attribute on ISerializable type.
        /// </summary>
        internal static string MissingSerializableAttributeOnISerializableTypeTitle {
            get {
                return ResourceManager.GetString("MissingSerializableAttributeOnISerializableTypeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types implementing ISerializable must provide a serialization constructor with the correct signature..
        /// </summary>
        internal static string MissingSerializationConstructorDescription {
            get {
                return ResourceManager.GetString("MissingSerializationConstructorDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; implements ISerializable but lacks the required serialization constructor.
        /// </summary>
        internal static string MissingSerializationConstructorMessage {
            get {
                return ResourceManager.GetString("MissingSerializationConstructorMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Missing serialization constructor.
        /// </summary>
        internal static string MissingSerializationConstructorTitle {
            get {
                return ResourceManager.GetString("MissingSerializationConstructorTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This code calls methods that are not fully implemented in Mono. Consider reviewing for Mono compatibility..
        /// </summary>
        internal static string MonoCompatibilityReviewDescription {
            get {
                return ResourceManager.GetString("MonoCompatibilityReviewDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This code may not be compatible with Mono.
        /// </summary>
        internal static string MonoCompatibilityReviewMessage {
            get {
                return ResourceManager.GetString("MonoCompatibilityReviewMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review Mono compatibility.
        /// </summary>
        internal static string MonoCompatibilityReviewTitle {
            get {
                return ResourceManager.GetString("MonoCompatibilityReviewTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exposing native fields publicly can lead to security and stability issues, as external code can modify or misuse these fields..
        /// </summary>
        internal static string NativeFieldsShouldNotBeVisibleDescription {
            get {
                return ResourceManager.GetString("NativeFieldsShouldNotBeVisibleDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field &apos;{0}&apos; is a publicly visible native field of type &apos;{1}&apos;.
        /// </summary>
        internal static string NativeFieldsShouldNotBeVisibleMessage {
            get {
                return ResourceManager.GetString("NativeFieldsShouldNotBeVisibleMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Native fields should not be publicly visible.
        /// </summary>
        internal static string NativeFieldsShouldNotBeVisibleTitle {
            get {
                return ResourceManager.GetString("NativeFieldsShouldNotBeVisibleTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using literal &apos;\n&apos; or &apos;\r&apos; for new lines is not portable across operating systems. Use Environment.NewLine instead..
        /// </summary>
        internal static string NewLineLiteralDescription {
            get {
                return ResourceManager.GetString("NewLineLiteralDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Environment.NewLine instead of new line literals.
        /// </summary>
        internal static string NewLineLiteralMessage {
            get {
                return ResourceManager.GetString("NewLineLiteralMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not use new line literals.
        /// </summary>
        internal static string NewLineLiteralTitle {
            get {
                return ResourceManager.GetString("NewLineLiteralTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Public static fields should be constant or readonly to avoid synchronization issues..
        /// </summary>
        internal static string NonConstantStaticFieldsShouldNotBeVisible_Description {
            get {
                return ResourceManager.GetString("NonConstantStaticFieldsShouldNotBeVisible_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The static field &apos;{0}&apos; should not be publicly visible.
        /// </summary>
        internal static string NonConstantStaticFieldsShouldNotBeVisible_Message {
            get {
                return ResourceManager.GetString("NonConstantStaticFieldsShouldNotBeVisible_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-constant static fields should not be visible.
        /// </summary>
        internal static string NonConstantStaticFieldsShouldNotBeVisible_Title {
            get {
                return ResourceManager.GetString("NonConstantStaticFieldsShouldNotBeVisible_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Obsolete attribute is more helpful if it includes advice on how to deal with the situation (e.g., the new recommended API to use)..
        /// </summary>
        internal static string ObsoleteMessagesShouldNotBeEmpty_Description {
            get {
                return ResourceManager.GetString("ObsoleteMessagesShouldNotBeEmpty_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Obsolete attribute on &apos;{0}&apos; should include a message providing guidance..
        /// </summary>
        internal static string ObsoleteMessagesShouldNotBeEmpty_Message {
            get {
                return ResourceManager.GetString("ObsoleteMessagesShouldNotBeEmpty_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete attribute should not be empty.
        /// </summary>
        internal static string ObsoleteMessagesShouldNotBeEmpty_Title {
            get {
                return ResourceManager.GetString("ObsoleteMessagesShouldNotBeEmpty_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods named Dispose should be reserved for types that implement IDisposable to avoid confusing developers..
        /// </summary>
        internal static string OnlyUseDisposeForIDisposableTypes_Description {
            get {
                return ResourceManager.GetString("OnlyUseDisposeForIDisposableTypes_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The method &apos;{0}&apos; is named Dispose but the containing type does not implement IDisposable.
        /// </summary>
        internal static string OnlyUseDisposeForIDisposableTypes_Message {
            get {
                return ResourceManager.GetString("OnlyUseDisposeForIDisposableTypes_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods named Dispose should be reserved for types that implement IDisposable.
        /// </summary>
        internal static string OnlyUseDisposeForIDisposableTypes_Title {
            get {
                return ResourceManager.GetString("OnlyUseDisposeForIDisposableTypes_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule fires if a type overloads operator &apos;+&apos; or &apos;-&apos;, or is a value type that overrides Equals(object), and does not overload ==..
        /// </summary>
        internal static string OperatorEqualsShouldBeOverloadedDescription {
            get {
                return ResourceManager.GetString("OperatorEqualsShouldBeOverloadedDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; overloads &apos;+&apos; or &apos;-&apos;, or is a value type overriding Equals(object), but doesn&apos;t overload &apos;==&apos;..
        /// </summary>
        internal static string OperatorEqualsShouldBeOverloadedMessage {
            get {
                return ResourceManager.GetString("OperatorEqualsShouldBeOverloadedMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Operator equals (==) should be overloaded.
        /// </summary>
        internal static string OperatorEqualsShouldBeOverloadedTitle {
            get {
                return ResourceManager.GetString("OperatorEqualsShouldBeOverloadedTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When a type overloads the equality operator, it should also override Object.Equals..
        /// </summary>
        internal static string OverrideEqualsMethodDescription {
            get {
                return ResourceManager.GetString("OverrideEqualsMethodDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; overloads &apos;==&apos; but does not override Equals(object)..
        /// </summary>
        internal static string OverrideEqualsMethodMessage {
            get {
                return ResourceManager.GetString("OverrideEqualsMethodMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override Equals(object) if == is overloaded.
        /// </summary>
        internal static string OverrideEqualsMethodTitle {
            get {
                return ResourceManager.GetString("OverrideEqualsMethodTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Value types should override Equals(object) and GetHashCode() methods to improve performance and correctness. The default implementations use reflection and can be inefficient..
        /// </summary>
        internal static string OverrideValueTypeDefaultsDescription {
            get {
                return ResourceManager.GetString("OverrideValueTypeDefaultsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Value type &apos;{0}&apos; does not override Equals(object) and GetHashCode().
        /// </summary>
        internal static string OverrideValueTypeDefaultsMessage {
            get {
                return ResourceManager.GetString("OverrideValueTypeDefaultsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override default implementations of Equals and GetHashCode for value types.
        /// </summary>
        internal static string OverrideValueTypeDefaultsTitle {
            get {
                return ResourceManager.GetString("OverrideValueTypeDefaultsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter names in overridden methods should match those in the base method to improve code clarity and usability..
        /// </summary>
        internal static string ParameterNamesShouldMatchOverriddenMethodDescription {
            get {
                return ResourceManager.GetString("ParameterNamesShouldMatchOverriddenMethodDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; parameter &apos;{1}&apos; does not match parameter name &apos;{2}&apos; in overridden method.
        /// </summary>
        internal static string ParameterNamesShouldMatchOverriddenMethodMessage {
            get {
                return ResourceManager.GetString("ParameterNamesShouldMatchOverriddenMethodMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter names should match overridden method.
        /// </summary>
        internal static string ParameterNamesShouldMatchOverriddenMethodTitle {
            get {
                return ResourceManager.GetString("ParameterNamesShouldMatchOverriddenMethodTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Making P/Invoke methods internal helps encapsulate native code dependencies and reduces the public API surface.
        /// </summary>
        internal static string PInvokeShouldNotBeVisibleDescription {
            get {
                return ResourceManager.GetString("PInvokeShouldNotBeVisibleDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to P/Invoke method &apos;{0}&apos; should not be public or protected; consider making it internal.
        /// </summary>
        internal static string PInvokeShouldNotBeVisibleMessage {
            get {
                return ResourceManager.GetString("PInvokeShouldNotBeVisibleMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to P/Invoke methods should not be publicly visible.
        /// </summary>
        internal static string PInvokeShouldNotBeVisibleTitle {
            get {
                return ResourceManager.GetString("PInvokeShouldNotBeVisibleTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using char overloads of string methods is more efficient than using string overloads when working with single characters..
        /// </summary>
        internal static string PreferCharOverloadDescription {
            get {
                return ResourceManager.GetString("PreferCharOverloadDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;{0}&apos; overload of &apos;{1}&apos; instead of string overload for better performance.
        /// </summary>
        internal static string PreferCharOverloadMessage {
            get {
                return ResourceManager.GetString("PreferCharOverloadMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer char overloads over string overloads when possible.
        /// </summary>
        internal static string PreferCharOverloadTitle {
            get {
                return ResourceManager.GetString("PreferCharOverloadTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods and properties which return a string, an array, a collection, or an enumerable should return an empty instance rather than null..
        /// </summary>
        internal static string PreferEmptyInstanceOverNull_Description {
            get {
                return ResourceManager.GetString("PreferEmptyInstanceOverNull_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The method or property &apos;{0}&apos; returns null; consider returning an empty instance instead.
        /// </summary>
        internal static string PreferEmptyInstanceOverNull_Message {
            get {
                return ResourceManager.GetString("PreferEmptyInstanceOverNull_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer returning an empty instance over null.
        /// </summary>
        internal static string PreferEmptyInstanceOverNull_Title {
            get {
                return ResourceManager.GetString("PreferEmptyInstanceOverNull_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods named like &apos;OnXxx&apos;, &apos;RaiseXxx&apos;, etc. can often be replaced by a real event to follow .NET design guidelines..
        /// </summary>
        internal static string PreferEventsOverMethodsDescription {
            get {
                return ResourceManager.GetString("PreferEventsOverMethodsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; name suggests event-like usage. Consider replacing it with an actual event..
        /// </summary>
        internal static string PreferEventsOverMethodsMessage {
            get {
                return ResourceManager.GetString("PreferEventsOverMethodsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer events over methods.
        /// </summary>
        internal static string PreferEventsOverMethodsTitle {
            get {
                return ResourceManager.GetString("PreferEventsOverMethodsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using generics instead of &apos;ref object&apos; provides type safety and a more intuitive API for consumers..
        /// </summary>
        internal static string PreferGenericsOverRefObject_Description {
            get {
                return ResourceManager.GetString("PreferGenericsOverRefObject_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid using &apos;ref object&apos;, prefer using generics for type safety.
        /// </summary>
        internal static string PreferGenericsOverRefObject_Message {
            get {
                return ResourceManager.GetString("PreferGenericsOverRefObject_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer Generics Over Ref Object.
        /// </summary>
        internal static string PreferGenericsOverRefObject_Title {
            get {
                return ResourceManager.GetString("PreferGenericsOverRefObject_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using types other than int64, int32, or string for indexers can be confusing unless there&apos;s a strong abstraction reason..
        /// </summary>
        internal static string PreferIntegerOrStringForIndexersDescription {
            get {
                return ResourceManager.GetString("PreferIntegerOrStringForIndexersDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Indexer in type &apos;{0}&apos; uses type &apos;{1}&apos; which is unusual. Consider using int, long, or string..
        /// </summary>
        internal static string PreferIntegerOrStringForIndexersMessage {
            get {
                return ResourceManager.GetString("PreferIntegerOrStringForIndexersMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer int/string for indexers.
        /// </summary>
        internal static string PreferIntegerOrStringForIndexersTitle {
            get {
                return ResourceManager.GetString("PreferIntegerOrStringForIndexersTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fields initialized with compile-time constants can be declared as const to improve performance and reduce code size..
        /// </summary>
        internal static string PreferLiteralOverInitOnlyFieldsDescription {
            get {
                return ResourceManager.GetString("PreferLiteralOverInitOnlyFieldsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field &apos;{0}&apos; can be made const.
        /// </summary>
        internal static string PreferLiteralOverInitOnlyFieldsMessage {
            get {
                return ResourceManager.GetString("PreferLiteralOverInitOnlyFieldsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer const over static readonly for compile-time constants.
        /// </summary>
        internal static string PreferLiteralOverInitOnlyFieldsTitle {
            get {
                return ResourceManager.GetString("PreferLiteralOverInitOnlyFieldsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is recommended to use SafeHandle instead of IntPtr or UIntPtr for handling unmanaged resources..
        /// </summary>
        internal static string PreferSafeHandle_Description {
            get {
                return ResourceManager.GetString("PreferSafeHandle_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider using SafeHandle instead of {0} for better resource management and safety.
        /// </summary>
        internal static string PreferSafeHandle_Message {
            get {
                return ResourceManager.GetString("PreferSafeHandle_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer SafeHandle over IntPtr or UIntPtr for unmanaged resources.
        /// </summary>
        internal static string PreferSafeHandle_Title {
            get {
                return ResourceManager.GetString("PreferSafeHandle_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using String.IsNullOrEmpty improves code readability and clarity over manual null and length checks..
        /// </summary>
        internal static string PreferStringIsNullOrEmptyDescription {
            get {
                return ResourceManager.GetString("PreferStringIsNullOrEmptyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use String.IsNullOrEmpty instead of separate null and length checks.
        /// </summary>
        internal static string PreferStringIsNullOrEmptyMessage {
            get {
                return ResourceManager.GetString("PreferStringIsNullOrEmptyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer String.IsNullOrEmpty over manual checks.
        /// </summary>
        internal static string PreferStringIsNullOrEmptyTitle {
            get {
                return ResourceManager.GetString("PreferStringIsNullOrEmptyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using XmlDocument, XPathDocument, or XmlNode in externally visible APIs can limit future changes and consumer languages&apos; usage..
        /// </summary>
        internal static string PreferXmlAbstractionsDescription {
            get {
                return ResourceManager.GetString("PreferXmlAbstractionsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member &apos;{0}&apos; uses concrete XML type &apos;{1}&apos;. Consider using abstract types like IXPathNavigable, XmlReader, or XmlWriter..
        /// </summary>
        internal static string PreferXmlAbstractionsMessage {
            get {
                return ResourceManager.GetString("PreferXmlAbstractionsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use XML abstractions instead of concrete XML implementations.
        /// </summary>
        internal static string PreferXmlAbstractionsTitle {
            get {
                return ResourceManager.GetString("PreferXmlAbstractionsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Event delegates should be checked for null and copied to a local variable to avoid race conditions..
        /// </summary>
        internal static string ProtectCallToEventDelegatesAnalyzer_Description {
            get {
                return ResourceManager.GetString("ProtectCallToEventDelegatesAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The event &apos;{0}&apos; should be checked for null before invocation.
        /// </summary>
        internal static string ProtectCallToEventDelegatesAnalyzer_Message {
            get {
                return ResourceManager.GetString("ProtectCallToEventDelegatesAnalyzer_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Protect call to event delegates.
        /// </summary>
        internal static string ProtectCallToEventDelegatesAnalyzer_Title {
            get {
                return ResourceManager.GetString("ProtectCallToEventDelegatesAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Some languages do not support operator overloading. Provide named methods to ensure full usability across languages..
        /// </summary>
        internal static string ProvideAlternativeNamesForOperatorOverloadsDescription {
            get {
                return ResourceManager.GetString("ProvideAlternativeNamesForOperatorOverloadsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; overloads operator &apos;{1}&apos; but does not provide a corresponding named method like &apos;{2}&apos;..
        /// </summary>
        internal static string ProvideAlternativeNamesForOperatorOverloadsMessage {
            get {
                return ResourceManager.GetString("ProvideAlternativeNamesForOperatorOverloadsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide named alternatives for overloaded operators.
        /// </summary>
        internal static string ProvideAlternativeNamesForOperatorOverloadsTitle {
            get {
                return ResourceManager.GetString("ProvideAlternativeNamesForOperatorOverloadsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks that the format string used with String.Format matches the other parameters used with the method..
        /// </summary>
        internal static string ProvideCorrectArgumentsToFormattingMethods_Description {
            get {
                return ResourceManager.GetString("ProvideCorrectArgumentsToFormattingMethods_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The format string in &apos;{0}&apos; does not match the arguments provided.
        /// </summary>
        internal static string ProvideCorrectArgumentsToFormattingMethods_Message {
            get {
                return ResourceManager.GetString("ProvideCorrectArgumentsToFormattingMethods_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide correct arguments to formatting methods.
        /// </summary>
        internal static string ProvideCorrectArgumentsToFormattingMethods_Title {
            get {
                return ResourceManager.GetString("ProvideCorrectArgumentsToFormattingMethods_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule verifies that valid regular expression strings are used as arguments..
        /// </summary>
        internal static string ProvideCorrectRegexPattern_Description {
            get {
                return ResourceManager.GetString("ProvideCorrectRegexPattern_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Invalid regex pattern in &apos;{0}&apos;.
        /// </summary>
        internal static string ProvideCorrectRegexPattern_Message {
            get {
                return ResourceManager.GetString("ProvideCorrectRegexPattern_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide correct regex pattern.
        /// </summary>
        internal static string ProvideCorrectRegexPattern_Title {
            get {
                return ResourceManager.GetString("ProvideCorrectRegexPattern_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule verifies that valid XML string arguments are passed as arguments..
        /// </summary>
        internal static string ProvideValidXmlString_Description {
            get {
                return ResourceManager.GetString("ProvideValidXmlString_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Invalid XML string in &apos;{0}&apos;.
        /// </summary>
        internal static string ProvideValidXmlString_Message {
            get {
                return ResourceManager.GetString("ProvideValidXmlString_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide valid XML string.
        /// </summary>
        internal static string ProvideValidXmlString_Title {
            get {
                return ResourceManager.GetString("ProvideValidXmlString_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule verifies that valid XPath expression strings are passed as arguments..
        /// </summary>
        internal static string ProvideValidXPathExpression_Description {
            get {
                return ResourceManager.GetString("ProvideValidXPathExpression_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Invalid XPath expression in &apos;{0}&apos;.
        /// </summary>
        internal static string ProvideValidXPathExpression_Message {
            get {
                return ResourceManager.GetString("ProvideValidXPathExpression_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide valid XPath expression.
        /// </summary>
        internal static string ProvideValidXPathExpression_Title {
            get {
                return ResourceManager.GetString("ProvideValidXPathExpression_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty finalizers or those that only set fields to null are unnecessary and can negatively impact garbage collection performance..
        /// </summary>
        internal static string RemoveUnneededFinalizerDescription {
            get {
                return ResourceManager.GetString("RemoveUnneededFinalizerDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Finalizer in class &apos;{0}&apos; is empty or only sets fields to null.
        /// </summary>
        internal static string RemoveUnneededFinalizerMessage {
            get {
                return ResourceManager.GetString("RemoveUnneededFinalizerMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove unneeded finalizer.
        /// </summary>
        internal static string RemoveUnneededFinalizerTitle {
            get {
                return ResourceManager.GetString("RemoveUnneededFinalizerTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unused local variables can be removed to reduce code clutter and potential confusion..
        /// </summary>
        internal static string RemoveUnusedLocalVariablesDescription {
            get {
                return ResourceManager.GetString("RemoveUnusedLocalVariablesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Local variable &apos;{0}&apos; is declared but never used.
        /// </summary>
        internal static string RemoveUnusedLocalVariablesMessage {
            get {
                return ResourceManager.GetString("RemoveUnusedLocalVariablesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove unused local variables.
        /// </summary>
        internal static string RemoveUnusedLocalVariablesTitle {
            get {
                return ResourceManager.GetString("RemoveUnusedLocalVariablesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using &apos;(x % 2) == 1&apos; to check for odd numbers will fail for negative numbers. Use &apos;(x % 2 != 0)&apos; or &apos;(x &amp; 1 == 1)&apos; instead..
        /// </summary>
        internal static string ReplaceIncompleteOddnessCheck_Description {
            get {
                return ResourceManager.GetString("ReplaceIncompleteOddnessCheck_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The modulo operation used to check oddness may fail for negative numbers; consider using &apos;(x % 2 != 0)&apos; or &apos;(x &amp; 1 == 1)&apos;.
        /// </summary>
        internal static string ReplaceIncompleteOddnessCheck_Message {
            get {
                return ResourceManager.GetString("ReplaceIncompleteOddnessCheck_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace incomplete oddness check.
        /// </summary>
        internal static string ReplaceIncompleteOddnessCheck_Title {
            get {
                return ResourceManager.GetString("ReplaceIncompleteOddnessCheck_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for integral divisions where the result is cast to a floating point type..
        /// </summary>
        internal static string ReviewCastOnIntegerDivision_Description {
            get {
                return ResourceManager.GetString("ReviewCastOnIntegerDivision_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cast on integer division may cause truncation.
        /// </summary>
        internal static string ReviewCastOnIntegerDivision_Message {
            get {
                return ResourceManager.GetString("ReviewCastOnIntegerDivision_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review cast on integer division.
        /// </summary>
        internal static string ReviewCastOnIntegerDivision_Title {
            get {
                return ResourceManager.GetString("ReviewCastOnIntegerDivision_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for integral multiply operations where the result is cast to a larger integral type..
        /// </summary>
        internal static string ReviewCastOnIntegerMultiplication_Description {
            get {
                return ResourceManager.GetString("ReviewCastOnIntegerMultiplication_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cast on integer multiplication may cause overflow.
        /// </summary>
        internal static string ReviewCastOnIntegerMultiplication_Message {
            get {
                return ResourceManager.GetString("ReviewCastOnIntegerMultiplication_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review cast on integer multiplication.
        /// </summary>
        internal static string ReviewCastOnIntegerMultiplication_Title {
            get {
                return ResourceManager.GetString("ReviewCastOnIntegerMultiplication_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for variables or fields that are assigned multiple times using the same value..
        /// </summary>
        internal static string ReviewDoubleAssignment_Description {
            get {
                return ResourceManager.GetString("ReviewDoubleAssignment_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable &apos;{0}&apos; is assigned twice with the same value.
        /// </summary>
        internal static string ReviewDoubleAssignment_Message {
            get {
                return ResourceManager.GetString("ReviewDoubleAssignment_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review double assignment.
        /// </summary>
        internal static string ReviewDoubleAssignment_Title {
            get {
                return ResourceManager.GetString("ReviewDoubleAssignment_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks to see if a type manages its identity in a consistent way..
        /// </summary>
        internal static string ReviewInconsistentIdentity_Description {
            get {
                return ResourceManager.GetString("ReviewInconsistentIdentity_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identity management for &apos;{0}&apos; is inconsistent.
        /// </summary>
        internal static string ReviewInconsistentIdentity_Message {
            get {
                return ResourceManager.GetString("ReviewInconsistentIdentity_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review inconsistent identity management.
        /// </summary>
        internal static string ReviewInconsistentIdentity_Title {
            get {
                return ResourceManager.GetString("ReviewInconsistentIdentity_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Some LINQ methods may have suboptimal performance in certain contexts. Review usage to see if a more efficient method or approach can be used..
        /// </summary>
        internal static string ReviewLinqMethodDescription {
            get {
                return ResourceManager.GetString("ReviewLinqMethodDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider replacing &apos;{0}&apos; with a more efficient alternative.
        /// </summary>
        internal static string ReviewLinqMethodMessage {
            get {
                return ResourceManager.GetString("ReviewLinqMethodMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review LINQ method usage for potential performance improvements.
        /// </summary>
        internal static string ReviewLinqMethodTitle {
            get {
                return ResourceManager.GetString("ReviewLinqMethodTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Locks should be used only for operations on variables. Consider using Interlocked for atomic operations..
        /// </summary>
        internal static string ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Description {
            get {
                return ResourceManager.GetString("ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The lock on &apos;{0}&apos; should be reviewed to ensure it is necessary.
        /// </summary>
        internal static string ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Message {
            get {
                return ResourceManager.GetString("ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review lock used only for operations on variables.
        /// </summary>
        internal static string ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Title {
            get {
                return ResourceManager.GetString("ReviewLockUsedOnlyForOperationsOnVariablesAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sealed types cannot be inherited from, so any InheritanceDemand on them will never be executed. Check if the permission is required and adjust accordingly..
        /// </summary>
        internal static string ReviewSealedTypeWithInheritanceDemandDescription {
            get {
                return ResourceManager.GetString("ReviewSealedTypeWithInheritanceDemandDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sealed type &apos;{0}&apos; has an InheritanceDemand which will never be enforced.
        /// </summary>
        internal static string ReviewSealedTypeWithInheritanceDemandMessage {
            get {
                return ResourceManager.GetString("ReviewSealedTypeWithInheritanceDemandMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review sealed type with InheritanceDemand.
        /// </summary>
        internal static string ReviewSealedTypeWithInheritanceDemandTitle {
            get {
                return ResourceManager.GetString("ReviewSealedTypeWithInheritanceDemandTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for variables or fields that are assigned to themselves..
        /// </summary>
        internal static string ReviewSelfAssignment_Description {
            get {
                return ResourceManager.GetString("ReviewSelfAssignment_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable &apos;{0}&apos; is assigned to itself.
        /// </summary>
        internal static string ReviewSelfAssignment_Message {
            get {
                return ResourceManager.GetString("ReviewSelfAssignment_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review self-assignment.
        /// </summary>
        internal static string ReviewSelfAssignment_Title {
            get {
                return ResourceManager.GetString("ReviewSelfAssignment_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The [SuppressUnmanagedCodeSecurity] attribute reduces security checks when executing unmanaged code. Its usage should be reviewed to ensure no security holes are introduced..
        /// </summary>
        internal static string ReviewSuppressUnmanagedCodeSecurityUsageDescription {
            get {
                return ResourceManager.GetString("ReviewSuppressUnmanagedCodeSecurityUsageDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type or method &apos;{0}&apos; is decorated with [SuppressUnmanagedCodeSecurity].
        /// </summary>
        internal static string ReviewSuppressUnmanagedCodeSecurityUsageMessage {
            get {
                return ResourceManager.GetString("ReviewSuppressUnmanagedCodeSecurityUsageMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review usage of [SuppressUnmanagedCodeSecurity].
        /// </summary>
        internal static string ReviewSuppressUnmanagedCodeSecurityUsageTitle {
            get {
                return ResourceManager.GetString("ReviewSuppressUnmanagedCodeSecurityUsageTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for empty blocks that produce useless control flow inside IL..
        /// </summary>
        internal static string ReviewUselessControlFlow_Description {
            get {
                return ResourceManager.GetString("ReviewUselessControlFlow_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Useless control flow detected.
        /// </summary>
        internal static string ReviewUselessControlFlow_Message {
            get {
                return ResourceManager.GetString("ReviewUselessControlFlow_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review useless control flow.
        /// </summary>
        internal static string ReviewUselessControlFlow_Title {
            get {
                return ResourceManager.GetString("ReviewUselessControlFlow_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for invalid integer to double conversion using BitConverter.Int64BitsToDouble method..
        /// </summary>
        internal static string ReviewUseOfInt64BitsToDouble_Description {
            get {
                return ResourceManager.GetString("ReviewUseOfInt64BitsToDouble_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Invalid use of BitConverter.Int64BitsToDouble.
        /// </summary>
        internal static string ReviewUseOfInt64BitsToDouble_Message {
            get {
                return ResourceManager.GetString("ReviewUseOfInt64BitsToDouble_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review use of Int64BitsToDouble.
        /// </summary>
        internal static string ReviewUseOfInt64BitsToDouble_Title {
            get {
                return ResourceManager.GetString("ReviewUseOfInt64BitsToDouble_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule checks for a modulo one operation on an integral type..
        /// </summary>
        internal static string ReviewUseOfModuloOneOnIntegers_Description {
            get {
                return ResourceManager.GetString("ReviewUseOfModuloOneOnIntegers_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Modulo one operation on an integer is likely a typo.
        /// </summary>
        internal static string ReviewUseOfModuloOneOnIntegers_Message {
            get {
                return ResourceManager.GetString("ReviewUseOfModuloOneOnIntegers_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review use of modulo one on integers.
        /// </summary>
        internal static string ReviewUseOfModuloOneOnIntegers_Title {
            get {
                return ResourceManager.GetString("ReviewUseOfModuloOneOnIntegers_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types implementing ISerializable should protect their GetObjectData method with a demand or link demand for SerializationFormatter permission to prevent unauthorized access..
        /// </summary>
        internal static string SecureGetObjectDataOverridesDescription {
            get {
                return ResourceManager.GetString("SecureGetObjectDataOverridesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GetObjectData method in type &apos;{0}&apos; is not protected with a security demand.
        /// </summary>
        internal static string SecureGetObjectDataOverridesMessage {
            get {
                return ResourceManager.GetString("SecureGetObjectDataOverridesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Secure GetObjectData overrides.
        /// </summary>
        internal static string SecureGetObjectDataOverridesTitle {
            get {
                return ResourceManager.GetString("SecureGetObjectDataOverridesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static constructors should be private to prevent external code from invoking them, which could lead to security vulnerabilities or unexpected behavior..
        /// </summary>
        internal static string StaticConstructorsShouldBePrivateDescription {
            get {
                return ResourceManager.GetString("StaticConstructorsShouldBePrivateDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static constructor for type &apos;{0}&apos; is not private.
        /// </summary>
        internal static string StaticConstructorsShouldBePrivateMessage {
            get {
                return ResourceManager.GetString("StaticConstructorsShouldBePrivateMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static constructors should be private.
        /// </summary>
        internal static string StaticConstructorsShouldBePrivateTitle {
            get {
                return ResourceManager.GetString("StaticConstructorsShouldBePrivateTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An executable assembly referencing System.Windows.Forms should be compiled with -target:winexe to prevent a console window from appearing under Windows..
        /// </summary>
        internal static string SystemWindowsFormsExecutableTargetDescription {
            get {
                return ResourceManager.GetString("SystemWindowsFormsExecutableTargetDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Executable assembly references System.Windows.Forms but is not compiled with -target:winexe.
        /// </summary>
        internal static string SystemWindowsFormsExecutableTargetMessage {
            get {
                return ResourceManager.GetString("SystemWindowsFormsExecutableTargetMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Executable referencing System.Windows.Forms should use Windows subsystem.
        /// </summary>
        internal static string SystemWindowsFormsExecutableTargetTitle {
            get {
                return ResourceManager.GetString("SystemWindowsFormsExecutableTargetTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Overridden ToString() methods should not return null. An appropriately descriptive string, or string.Empty, should be returned instead to make the value more useful..
        /// </summary>
        internal static string ToStringShouldNotReturnNull_Description {
            get {
                return ResourceManager.GetString("ToStringShouldNotReturnNull_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The ToString() method returns null; consider returning a descriptive string or string.Empty.
        /// </summary>
        internal static string ToStringShouldNotReturnNull_Message {
            get {
                return ResourceManager.GetString("ToStringShouldNotReturnNull_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ToString() should not return null.
        /// </summary>
        internal static string ToStringShouldNotReturnNull_Title {
            get {
                return ResourceManager.GetString("ToStringShouldNotReturnNull_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Defining types in namespaces prevents naming collisions and clarifies your assembly&apos;s API..
        /// </summary>
        internal static string TypesShouldBeInsideNamespacesDescription {
            get {
                return ResourceManager.GetString("TypesShouldBeInsideNamespacesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Externally visible type &apos;{0}&apos; is declared outside of any namespace..
        /// </summary>
        internal static string TypesShouldBeInsideNamespacesMessage {
            get {
                return ResourceManager.GetString("TypesShouldBeInsideNamespacesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types should be inside namespaces.
        /// </summary>
        internal static string TypesShouldBeInsideNamespacesTitle {
            get {
                return ResourceManager.GetString("TypesShouldBeInsideNamespacesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All fields that implement IDisposable should be disposed. Types holding such fields must implement IDisposable..
        /// </summary>
        internal static string TypesWithDisposableFieldsShouldBeDisposableDescription {
            get {
                return ResourceManager.GetString("TypesWithDisposableFieldsShouldBeDisposableDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; has disposable field &apos;{1}&apos; but does not implement IDisposable or properly dispose its fields..
        /// </summary>
        internal static string TypesWithDisposableFieldsShouldBeDisposableMessage {
            get {
                return ResourceManager.GetString("TypesWithDisposableFieldsShouldBeDisposableMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types with disposable fields should implement IDisposable.
        /// </summary>
        internal static string TypesWithDisposableFieldsShouldBeDisposableTitle {
            get {
                return ResourceManager.GetString("TypesWithDisposableFieldsShouldBeDisposableTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types that contain IntPtr, UIntPtr, or HandleRef fields must implement IDisposable to properly free them..
        /// </summary>
        internal static string TypesWithNativeFieldsShouldBeDisposableDescription {
            get {
                return ResourceManager.GetString("TypesWithNativeFieldsShouldBeDisposableDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; contains native field &apos;{1}&apos; but does not implement IDisposable..
        /// </summary>
        internal static string TypesWithNativeFieldsShouldBeDisposableMessage {
            get {
                return ResourceManager.GetString("TypesWithNativeFieldsShouldBeDisposableMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types with native fields should implement IDisposable.
        /// </summary>
        internal static string TypesWithNativeFieldsShouldBeDisposableTitle {
            get {
                return ResourceManager.GetString("TypesWithNativeFieldsShouldBeDisposableTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers should follow .NET naming conventions for casing to improve readability and maintain consistency..
        /// </summary>
        internal static string UseCorrectCasingDescription {
            get {
                return ResourceManager.GetString("UseCorrectCasingDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; does not follow correct casing convention.
        /// </summary>
        internal static string UseCorrectCasingMessage {
            get {
                return ResourceManager.GetString("UseCorrectCasingMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use correct casing in identifiers.
        /// </summary>
        internal static string UseCorrectCasingTitle {
            get {
                return ResourceManager.GetString("UseCorrectCasingTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IDisposable implementation should have a non-virtual public Dispose(), a protected virtual Dispose(bool), and (optionally) a finalizer if unsealed..
        /// </summary>
        internal static string UseCorrectDisposeSignaturesDescription {
            get {
                return ResourceManager.GetString("UseCorrectDisposeSignaturesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; does not follow standard Dispose pattern guidelines: {1}.
        /// </summary>
        internal static string UseCorrectDisposeSignaturesMessage {
            get {
                return ResourceManager.GetString("UseCorrectDisposeSignaturesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use correct dispose signatures.
        /// </summary>
        internal static string UseCorrectDisposeSignaturesTitle {
            get {
                return ResourceManager.GetString("UseCorrectDisposeSignaturesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that interfaces are prefixed with &apos;I&apos;, types are not prefixed with &apos;C&apos;, and generic parameters are correctly prefixed..
        /// </summary>
        internal static string UseCorrectPrefixDescription {
            get {
                return ResourceManager.GetString("UseCorrectPrefixDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; {2}.
        /// </summary>
        internal static string UseCorrectPrefixMessage {
            get {
                return ResourceManager.GetString("UseCorrectPrefixMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use correct prefix in type names.
        /// </summary>
        internal static string UseCorrectPrefixTitle {
            get {
                return ResourceManager.GetString("UseCorrectPrefixTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Methods decorated with serialization attributes should be private, return void, and have a single parameter of type StreamingContext..
        /// </summary>
        internal static string UseCorrectSignatureForSerializationMethodsDescription {
            get {
                return ResourceManager.GetString("UseCorrectSignatureForSerializationMethodsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; has an incorrect signature for a serialization callback.
        /// </summary>
        internal static string UseCorrectSignatureForSerializationMethodsMessage {
            get {
                return ResourceManager.GetString("UseCorrectSignatureForSerializationMethodsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use correct signature for serialization methods.
        /// </summary>
        internal static string UseCorrectSignatureForSerializationMethodsTitle {
            get {
                return ResourceManager.GetString("UseCorrectSignatureForSerializationMethodsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that types have the correct suffix based on the base types or interfaces they inherit from or implement..
        /// </summary>
        internal static string UseCorrectSuffixDescription {
            get {
                return ResourceManager.GetString("UseCorrectSuffixDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0}.
        /// </summary>
        internal static string UseCorrectSuffixMessage {
            get {
                return ResourceManager.GetString("UseCorrectSuffixMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use correct suffix in type names.
        /// </summary>
        internal static string UseCorrectSuffixTitle {
            get {
                return ResourceManager.GetString("UseCorrectSuffixTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An enum with bits that can be ORed together should declare [Flags] to improve usage and debugging..
        /// </summary>
        internal static string UseFlagsAttributeDescription {
            get {
                return ResourceManager.GetString("UseFlagsAttributeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum &apos;{0}&apos; has members that look like bit flags but is not decorated with [Flags]..
        /// </summary>
        internal static string UseFlagsAttributeMessage {
            get {
                return ResourceManager.GetString("UseFlagsAttributeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider [Flags] attribute for bitmask enum.
        /// </summary>
        internal static string UseFlagsAttributeTitle {
            get {
                return ResourceManager.GetString("UseFlagsAttributeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replacing custom delegate types with &apos;EventHandler&lt;TEventArgs&gt;&apos; improves consistency and leverages built-in .NET patterns..
        /// </summary>
        internal static string UseGenericEventHandler_Description {
            get {
                return ResourceManager.GetString("UseGenericEventHandler_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;EventHandler&lt;TEventArgs&gt;&apos; instead of custom delegate types.
        /// </summary>
        internal static string UseGenericEventHandler_Message {
            get {
                return ResourceManager.GetString("UseGenericEventHandler_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Generic EventHandler&lt;TEventArgs&gt;.
        /// </summary>
        internal static string UseGenericEventHandler_Title {
            get {
                return ResourceManager.GetString("UseGenericEventHandler_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using the &apos;is&apos; operator simplifies code and can improve performance over using &apos;as&apos; followed by a null check..
        /// </summary>
        internal static string UseIsOperatorDescription {
            get {
                return ResourceManager.GetString("UseIsOperatorDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expression &apos;{0}&apos; can be simplified using the &apos;is&apos; operator.
        /// </summary>
        internal static string UseIsOperatorMessage {
            get {
                return ResourceManager.GetString("UseIsOperatorMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;is&apos; operator instead of complex cast checks.
        /// </summary>
        internal static string UseIsOperatorTitle {
            get {
                return ResourceManager.GetString("UseIsOperatorTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using managed alternatives improves portability and maintainability of code..
        /// </summary>
        internal static string UseManagedAlternativesToPInvokeDescription {
            get {
                return ResourceManager.GetString("UseManagedAlternativesToPInvokeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use managed alternative &apos;{1}&apos; instead of P/Invoke method &apos;{0}&apos;.
        /// </summary>
        internal static string UseManagedAlternativesToPInvokeMessage {
            get {
                return ResourceManager.GetString("UseManagedAlternativesToPInvokeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use managed alternatives to P/Invoke methods.
        /// </summary>
        internal static string UseManagedAlternativesToPInvokeTitle {
            get {
                return ResourceManager.GetString("UseManagedAlternativesToPInvokeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Public methods should check if the object is disposed and throw ObjectDisposedException if it is.
        /// </summary>
        internal static string UseObjectDisposedExceptionDescription {
            get {
                return ResourceManager.GetString("UseObjectDisposedExceptionDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; should throw ObjectDisposedException if object is disposed.
        /// </summary>
        internal static string UseObjectDisposedExceptionMessage {
            get {
                return ResourceManager.GetString("UseObjectDisposedExceptionMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Throw ObjectDisposedException when disposed object is accessed.
        /// </summary>
        internal static string UseObjectDisposedExceptionTitle {
            get {
                return ResourceManager.GetString("UseObjectDisposedExceptionTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enumerations decorated with [Flags] should have plural names to indicate that multiple values can be combined..
        /// </summary>
        internal static string UsePluralNameInEnumFlagsDescription {
            get {
                return ResourceManager.GetString("UsePluralNameInEnumFlagsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum &apos;{0}&apos; is marked with [Flags] but its name is not plural.
        /// </summary>
        internal static string UsePluralNameInEnumFlagsMessage {
            get {
                return ResourceManager.GetString("UsePluralNameInEnumFlagsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use plural name for enums marked with [Flags].
        /// </summary>
        internal static string UsePluralNameInEnumFlagsTitle {
            get {
                return ResourceManager.GetString("UsePluralNameInEnumFlagsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use terms that are consistent with .NET Framework guidelines to improve code clarity and consistency..
        /// </summary>
        internal static string UsePreferredTermsDescription {
            get {
                return ResourceManager.GetString("UsePreferredTermsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier &apos;{0}&apos; contains &apos;{1}&apos;, consider using &apos;{2}&apos; instead.
        /// </summary>
        internal static string UsePreferredTermsMessage {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use preferred terms in identifiers.
        /// </summary>
        internal static string UsePreferredTermsTitle {
            get {
                return ResourceManager.GetString("UsePreferredTermsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enums not marked with [Flags] should have singular names, while enums with [Flags] should have plural names..
        /// </summary>
        internal static string UseSingularNameInEnumsUnlessAreFlagsDescription {
            get {
                return ResourceManager.GetString("UseSingularNameInEnumsUnlessAreFlagsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum &apos;{0}&apos; should have a {1} name.
        /// </summary>
        internal static string UseSingularNameInEnumsUnlessAreFlagsMessage {
            get {
                return ResourceManager.GetString("UseSingularNameInEnumsUnlessAreFlagsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use singular name in enums unless they are marked with [Flags].
        /// </summary>
        internal static string UseSingularNameInEnumsUnlessAreFlagsTitle {
            get {
                return ResourceManager.GetString("UseSingularNameInEnumsUnlessAreFlagsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Windows Forms applications require the entry point method to be marked with [STAThread] attribute to function properly..
        /// </summary>
        internal static string UseSTAThreadAttributeOnSWFEntryPointsDescription {
            get {
                return ResourceManager.GetString("UseSTAThreadAttributeOnSWFEntryPointsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Entry point of Windows Forms application should be marked with [STAThread] attribute.
        /// </summary>
        internal static string UseSTAThreadAttributeOnSWFEntryPointsMessage {
            get {
                return ResourceManager.GetString("UseSTAThreadAttributeOnSWFEntryPointsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use [STAThread] on Windows Forms entry points.
        /// </summary>
        internal static string UseSTAThreadAttributeOnSWFEntryPointsTitle {
            get {
                return ResourceManager.GetString("UseSTAThreadAttributeOnSWFEntryPointsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using &apos;string.Empty&apos; can improve readability and consistency over using empty string literals..
        /// </summary>
        internal static string UseStringEmptyDescription {
            get {
                return ResourceManager.GetString("UseStringEmptyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;string.Empty&apos; instead of empty string literal.
        /// </summary>
        internal static string UseStringEmptyMessage {
            get {
                return ResourceManager.GetString("UseStringEmptyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;string.Empty&apos; instead of empty string literal.
        /// </summary>
        internal static string UseStringEmptyTitle {
            get {
                return ResourceManager.GetString("UseStringEmptyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Calling GC.SuppressFinalize prevents unnecessary finalization and improves performance when the Dispose method has already cleaned up resources..
        /// </summary>
        internal static string UseSuppressFinalizeOnIDisposableTypeWithFinalizerDescription {
            get {
                return ResourceManager.GetString("UseSuppressFinalizeOnIDisposableTypeWithFinalizerDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; implements IDisposable and has a finalizer but does not call GC.SuppressFinalize(this) in Dispose().
        /// </summary>
        internal static string UseSuppressFinalizeOnIDisposableTypeWithFinalizerMessage {
            get {
                return ResourceManager.GetString("UseSuppressFinalizeOnIDisposableTypeWithFinalizerMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Call GC.SuppressFinalize in Dispose method.
        /// </summary>
        internal static string UseSuppressFinalizeOnIDisposableTypeWithFinalizerTitle {
            get {
                return ResourceManager.GetString("UseSuppressFinalizeOnIDisposableTypeWithFinalizerTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using &apos;Type.EmptyTypes&apos; avoids unnecessary allocations and improves performance..
        /// </summary>
        internal static string UseTypeEmptyTypesDescription {
            get {
                return ResourceManager.GetString("UseTypeEmptyTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;Type.EmptyTypes&apos; instead of creating a new empty Type array.
        /// </summary>
        internal static string UseTypeEmptyTypesMessage {
            get {
                return ResourceManager.GetString("UseTypeEmptyTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;Type.EmptyTypes&apos; instead of &apos;new Type[0]&apos;.
        /// </summary>
        internal static string UseTypeEmptyTypesTitle {
            get {
                return ResourceManager.GetString("UseTypeEmptyTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use value in property setter.
        /// </summary>
        internal static string UseValueInPropertySetter_Description {
            get {
                return ResourceManager.GetString("UseValueInPropertySetter_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Property setter does not use &apos;value&apos;.
        /// </summary>
        internal static string UseValueInPropertySetter_Message {
            get {
                return ResourceManager.GetString("UseValueInPropertySetter_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule ensures all setter properties uses the value argument passed to the property..
        /// </summary>
        internal static string UseValueInPropertySetter_Title {
            get {
                return ResourceManager.GetString("UseValueInPropertySetter_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Writing to static fields from instance methods can cause issues in multithreaded environments. Consider refactoring to avoid this pattern..
        /// </summary>
        internal static string WriteStaticFieldFromInstanceMethod_Description {
            get {
                return ResourceManager.GetString("WriteStaticFieldFromInstanceMethod_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The instance method &apos;{0}&apos; writes to static field &apos;{1}&apos;, which can cause issues in multithreaded environments.
        /// </summary>
        internal static string WriteStaticFieldFromInstanceMethod_Message {
            get {
                return ResourceManager.GetString("WriteStaticFieldFromInstanceMethod_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not write to static fields from instance methods.
        /// </summary>
        internal static string WriteStaticFieldFromInstanceMethod_Title {
            get {
                return ResourceManager.GetString("WriteStaticFieldFromInstanceMethod_Title", resourceCulture);
            }
        }
    }
}
